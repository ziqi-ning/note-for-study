# 线程管理1-9

## 一、线程：概念、特点、创建

- 摘要
  - 线程可以理解为“轻量级进程”，在同一进程内共享地址空间和大部分资源，相比进程切换开销更小、资源占用更低。
  - 线程共享可执行指令、静态数据、文件描述符、工作目录与部分 ID；但拥有各自的线程 ID、寄存器上下文、栈、errno、调度状态等私有资源。
  - 在 Linux 中，用户态通常通过 pthread 线程库来创建与管理线程；编译和链接时需要显式链接 -lpthread。
  - 创建线程时应确保有足够的执行时间（如 sleep 或 pthread_join），否则主线程过早退出会导致子线程来不及运行完成，表现为输出不确定。

- 重点
  - 线程的概念与特点
  - 线程的创建
  - 常见编译/链接错误与运行时不确定性原因

- 核心概念与资源划分
  - 共享资源（同一进程内的所有线程共享）
    - 可执行指令、静态/全局数据段
    - 文件描述符（fd）
    - 进程级的当前工作目录、用户/组 ID 等
  - 私有资源（每个线程独有）
    - 线程 ID（pthread_t）
    - 寄存器上下文（含程序计数器 PC）
    - 线程栈（影响局部变量的存储）
    - errno
    - 线程的调度状态
  - 与进程的对比
    - 不同进程的地址空间独立，彼此不能直接访问对方的全局变量或已打开文件描述符（即使文件描述符数字相同，也不是同一个对象）。
    - 同一进程内的线程共享地址空间，因此能访问相同的全局/静态数据与相同的文件描述符。

- pthread 线程库与创建函数
  - 函数原型
    ```c
    int pthread_create(
        pthread_t *thread,
        const pthread_attr_t *attr,
        void *(*start_routine)(void *),
        void *arg
    );
    ```
  - 参数说明
    - thread：输出参数，返回新线程的 ID。
    - attr：线程属性，传 NULL 使用默认属性。
    - start_routine：线程入口函数，原型固定为 void* (*)(void*)。
    - arg：传给线程入口函数的单个参数（void* 指针）。
  - 返回值
    - 成功返回 0；失败返回错误码。

- 常见错误与解决
  - 编译期类型不匹配
    - 症状：传入的第三个参数指针类型不兼容（期望 void* (*)(void*)，实际写成了 int* 或返回 int*）。
    - 解决：
      - 更正线程函数签名为 void* thread_func(void* arg) 并按需转换参数类型（推荐）。
      - 或对函数指针进行强制类型转换（不推荐，易埋隐患）。
  - 链接错误：undefined reference to pthread_create
    - 原因：未链接 pthread 库。
    - 解决：编译命令添加 -lpthread（示例见下文）。
  - 运行结果不确定/打印不完整
    - 原因：主线程过早退出，子线程未能执行或打印完成。
    - 解决：在退出前 sleep 留出时间，或用 pthread_join 等待子线程结束（推荐）。

- 示例代码 1：最小可运行示例（用 sleep 留时间）
  ```c
  // file: create_sleep.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* test_thread(void* arg) {
      printf("This is the thread.\n");
      return NULL; // 等价于 (void*)0
  }

  int main(void) {
      pthread_t tid;
      int ret = pthread_create(&tid, NULL, test_thread, NULL);
      if (ret != 0) {
          // 创建失败时，ret 即错误码
          printf("pthread_create failed, err=%d\n", ret);
          return 1;
      }

      printf("This is the main thread.\n");
      // 给子线程一些时间（示例做法，非最佳实践）
      sleep(1);
      return 0; // main 退出将结束进程，未 join 的线程也会随之结束
  }
  ```

- 示例代码 2：更稳妥的写法（使用 pthread_join）
  ```c
  // file: create_join.c
  #include <stdio.h>
  #include <pthread.h>

  void* test_thread(void* arg) {
      (void)arg; // 未使用参数
      printf("This is the thread.\n");
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      int ret = pthread_create(&tid, NULL, test_thread, NULL);
      if (ret != 0) {
          printf("pthread_create failed, err=%d\n", ret);
          return 1;
      }

      printf("This is the main thread.\n");

      // 阻塞等待子线程结束，确保输出完整且资源正确回收
      pthread_join(tid, NULL);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  # 编译并链接 pthread 库
  gcc -o create_sleep create_sleep.c -lpthread
  gcc -o create_join  create_join.c  -lpthread

  # 运行
  ./create_sleep
  ./create_join
  ```

- 小结与注意事项
  - 在线程函数签名上，务必使用 void* (*)(void*)，参数在函数体内自行转换为需要的类型。
  - 链接时一定加上 -lpthread，否则会出现 undefined reference to pthread_create 等链接错误。
  - 为避免主线程过早结束导致子线程未完成，推荐使用 pthread_join，而不是简单的 sleep。
  - 线程共享进程资源，需注意并发读写的同步问题（后续可结合互斥锁、条件变量、信号量等机制）。



## 二、线程：退出、线程 ID、参数传递、多线程创建与常见错误（pthread）

- 摘要
  - 介绍 pthread_exit 的用法与语义；说明在线程函数中 return 与 pthread_exit 的关系与差异点（清理处理等）。
  - 讲解获取线程 ID 的两种方式：通过 pthread_create 输出参数和在线程内部通过 pthread_self。
  - 系统化展示线程参数传递的两种方法：指针传递（需正确强转与生存期保证）和“值传递”（通过 intptr_t 安全地把整数装载到 void*）。
  - 通过创建多个线程展示“传地址”的典型坑（所有线程看到相同最终值），并给出三种稳妥的解法。
  - 分析“stack smashing detected”（栈被破坏）常见成因：数组越界、过大栈对象等，及规避与排查建议。

- 重点
  - 线程退出函数与返回值
  - 线程 ID 的两种获取方法
  - 指针与整数的区别与转换
  - 线程参数传递：指针传递的风险与值传递的安全做法
  - 多线程创建时的典型坑与修复
  - “stack smashing detected” 的定位与避免

- API 速览（与视频术语对照）
  - pthread_exit(void* retval)
  - pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg)
  - pthread_self(void)
  - pthread_join(pthread_t thread, void** retval)

- 示例 1：pthread_exit 与 return 的效果对比
  ```c
  // file: ex1_exit.c
  #include <stdio.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("Inside worker before exit\n");
      pthread_exit((void*)0x2A);  // 返回值将被 pthread_join 接收
      // 这一行不会执行
      printf("After pthread_exit (unreachable)\n");
      return NULL; // 与 pthread_exit 二选一；return 等价于 pthread_exit(retval)
  }

  int main(void) {
      pthread_t tid;
      if (pthread_create(&tid, NULL, worker, NULL) != 0) return 1;

      void* ret = NULL;
      pthread_join(tid, &ret);
      printf("Worker returned via pthread_exit: %p\n", ret);
      return 0;
  }
  ```

- 示例 2：线程 ID 的获取与打印
  ```c
  // file: ex2_tid.c
  #include <stdio.h>
  #include <pthread.h>
  #include <unistd.h>

  void* worker(void* arg) {
      (void)arg;
      pthread_t self = pthread_self();
      printf("Worker self tid=%lu\n", (unsigned long)self);
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      printf("Main got new thread tid from pthread_create: %lu\n", (unsigned long)tid);
      pthread_join(tid, NULL);
      return 0;
  }
  ```

- 示例 3：参数传递（指针方式，正确强转）
  ```c
  // file: ex3_arg_pointer.c
  #include <stdio.h>
  #include <pthread.h>

  void* worker(void* arg) {
      // 将 void* 强转为具体类型指针，再解引用
      int value = *(int*)arg;
      printf("Pointer-passed value = %d\n", value);
      return NULL;
  }

  int main(void) {
      int x = 5; // 确保线程存活期间 x 仍然有效
      pthread_t tid;
      pthread_create(&tid, NULL, worker, &x);
      pthread_join(tid, NULL);
      return 0;
  }
  ```
  注意
  - 不要对 void* 直接解引用（必须先强转为正确的指针类型）。
  - 传入的是地址时，必须保证该对象在线程使用期间仍然存活且不会被并发修改。

- 示例 4：参数传递（值传递，使用 intptr_t 安全装载）
  ```c
  // file: ex4_arg_value.c
  #include <stdio.h>
  #include <stdint.h>   // intptr_t
  #include <pthread.h>

  void* worker(void* arg) {
      int idx = (int)(intptr_t)arg; // 从 void* 安全拆回整数
      printf("Value-passed idx = %d\n", idx);
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      int idx = 42;
      // 将整数通过 intptr_t 转换后装入 void*
      pthread_create(&tid, NULL, worker, (void*)(intptr_t)idx);
      pthread_join(tid, NULL);
      return 0;
  }
  ```
  说明
  - 与直接把 int 强转为 void* 相比，经由 intptr_t 可在 32/64 位平台上保持定义良好与可移植。
  - 若类型宽度不一致（如直接把 64 位长整形塞进 32 位指针），会出现告警乃至截断风险。

- 示例 5：创建多个线程与“传地址”的典型坑及修复
  ```c
  // file: ex5_multi_threads.c
  #include <stdio.h>
  #include <stdint.h>
  #include <pthread.h>

  enum { N = 5 };

  // 值传递版本：推荐
  void* worker_by_value(void* arg) {
      int idx = (int)(intptr_t)arg;
      printf("[value] thread idx=%d\n", idx);
      return NULL;
  }

  // 指针传递版本（配套独立存储）：安全
  struct args { int idx; };
  void* worker_by_ptr(void* arg) {
      struct args* a = (struct args*)arg;
      printf("[ptr] thread idx=%d\n", a->idx);
      return NULL;
  }

  int main(void) {
      pthread_t tids[N];

      // 反例：不要把循环变量 i 的地址传给所有线程（都会看到最终相同的值）
      // for (int i = 0; i < N; ++i) {
      //     pthread_create(&tids[i], NULL, worker_by_value, &i); // 反例
      // }

      // A. 值传递（推荐）
      for (int i = 0; i < N; ++i) {
          pthread_create(&tids[i], NULL, worker_by_value, (void*)(intptr_t)i);
      }
      for (int i = 0; i < N; ++i) pthread_join(tids[i], NULL);

      // B. 为每个线程准备独立存储（数组/堆），指针传递也安全
      struct args a[N];
      for (int i = 0; i < N; ++i) a[i].idx = i;
      for (int i = 0; i < N; ++i) {
          pthread_create(&tids[i], NULL, worker_by_ptr, &a[i]);
      }
      for (int i = 0; i < N; ++i) pthread_join(tids[i], NULL);

      return 0;
  }
  ```
  说明
  - 线程的执行时序非确定，打印顺序可能与创建顺序不同。
  - 通过值传递或为每个线程准备独立且稳定的存储，避免“全部打印相同值”的竞态。

- 常见错误：“stack smashing detected”（栈被破坏）
  - 常见原因
    - 数组越界（如声明 pthread_t tids[5] 却访问 tids[5] 索引，合法索引仅 0..4）
    - 在栈上定义过大的数组或结构，超过栈容量
    - 写越界（如错误的 memcpy/memset 长度）
  - 排查建议
    - 检查所有数组下标范围与循环边界
    - 使用 -Wall -Wextra -Wshadow -Wconversion 等编译选项尽早发现问题
    - 开启地址/未定义行为检测：-fsanitize=address,undefined（开发环境）
    - 对大对象使用堆分配（malloc/free）或静态/全局存储
    - 观察崩溃现场信息（函数名、行号）定位具体越界点

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -o ex1_exit ex1_exit.c -lpthread
  gcc -Wall -Wextra -O2 -o ex2_tid  ex2_tid.c  -lpthread
  gcc -Wall -Wextra -O2 -o ex3_arg_pointer ex3_arg_pointer.c -lpthread
  gcc -Wall -Wextra -O2 -o ex4_arg_value   ex4_arg_value.c   -lpthread
  gcc -Wall -Wextra -O2 -o ex5_multi_threads ex5_multi_threads.c -lpthread
  ```

- 小结
  - 在线程函数中，return retval 等价于 pthread_exit(retval)；通常推荐显式使用 pthread_exit 以配合清理流程。
  - 打印 pthread_t 可在 Linux 上使用 %lu 并强转为 (unsigned long) 输出；更通用的方式是仅比较（pthread_equal）或存储/传递而非格式化打印。
  - 参数传递优先考虑值传递（intptr_t 装载），指针传递需保证对象生存期与不被并发修改。
  - 多线程创建时避免把同一地址（如循环变量 i 的地址）传给所有线程。
  - 出现 “stack smashing detected” 优先检查数组越界与栈对象大小。


## 三、线程回收与分离：pthread_join、pthread_detach、分离属性与线程查看

- 摘要
  - 线程资源默认不会在线程结束后自动释放（joinable 状态），需要使用 pthread_join 回收；pthread_join 为阻塞调用。
  - 为避免阻塞或丢失回收，线程可设置为“分离”状态（detached），由系统在退出时自动清理，常见做法：
    - 创建后由创建者调用 pthread_detach(tid)
    - 在线程内自我分离 pthread_detach(pthread_self())
    - 在创建时用属性设置为分离 pthread_attr_setdetachstate(..., PTHREAD_CREATE_DETACHED)
  - Linux 查看线程：ps -eLf（-L 显示线程，-f 显示全字段）；TID/LWP 为线程 ID。

- 重点
  - 线程回收方法：pthread_join（阻塞）
  - 线程分离的两种方式：detach 函数、自创建时设为分离属性
  - 多线程 join 的阻塞与次序问题
  - 线程运行状态查看：ps -eLf（TID/LWP 列）

- 查看线程运行状态（Linux）
  - 常用命令
    - ps -eLf | grep 程序名
    - 字段说明（常见列）：PID（进程号）、PPID（父进程号）、LWP/TID（线程号）
  - 便于观察可让主/子线程循环 sleep，避免进程过快退出导致看不到线程

- 线程回收：pthread_join
  - 原型
    - int pthread_join(pthread_t thread, void** retval);
  - 特性
    - 阻塞等待 thread 结束；若已结束立即返回
    - 仅适用于 joinable 线程；对 detached 线程调用会返回错误（EINVAL/ESRCH）
  - 返回值
    - 0 表示成功；非 0 为错误码

- 多线程 join 的阻塞问题与常见策略
  - 问题
    - 顺序 join(tids[0]..tids[N-1]) 时，若 tids[0] 长时间未结束，其它已结束线程也无法及时回收
  - 策略
    - 线程改为 detached（推荐简化回收）
    - 或使用非标准扩展 pthread_tryjoin_np 轮询回收已结束线程（可用性依赖平台）
    - 或自行设计完成队列/条件变量，结束时通知主线程按实际完成次序回收资源

- 线程分离（detached）
  - pthread_detach(pthread_t thread)
    - 将目标线程标记为 detached；线程退出即系统回收资源；之后不可 join
  - 自我分离
    - 在线程函数内调用 pthread_detach(pthread_self())，无需外部持有 tid
  - 创建时设置分离属性
    - pthread_attr_init / pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) / pthread_attr_destroy
    - 调用 pthread_create 时传入 attr

- 注意事项
  - 不要对已 detached 的线程再调用 pthread_join（会失败）
  - 若使用属性对象，创建后记得 pthread_attr_destroy 释放属性对象
  - 即使线程 detached，进程结束时仍会终止所有线程；如需确保任务完成，请设计同步机制或在退出前等待
  - 推荐编译选项：-pthread（或 -lpthread），并启用 -Wall -Wextra 便于及早发现问题

- 示例 1：用 ps 观察线程（让线程持续运行便于查看）
  ```c
  // file: ex_ps_observe.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      long idx = (long)arg;
      printf("worker %ld started (tid=%lu)\n", idx, (unsigned long)pthread_self());
      while (1) sleep(10); // 持续存活，便于 ps 观察
      return NULL;
  }

  int main(void) {
      const int N = 5;
      pthread_t tids[N];
      for (long i = 0; i < N; ++i) {
          pthread_create(&tids[i], NULL, worker, (void*)i);
      }
      while (1) sleep(10); // 主线程不退出
      return 0;
  }
  ```
  - 观察命令
    - ps -eLf | grep ex_ps_observe

- 示例 2：基础回收（pthread_join 阻塞等待）
  ```c
  // file: ex_join_basic.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("child thread running...\n");
      sleep(1);
      pthread_exit("done"); // 返回指向常量区的指针，安全可打印
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);

      void* retval = NULL;
      int rc = pthread_join(tid, &retval); // 阻塞直到子线程结束
      if (rc == 0) {
          printf("joined, retval=%s\n", (char*)retval);
      } else {
          printf("join failed, rc=%d\n", rc);
      }
      return 0;
  }
  ```

- 示例 3：多线程顺序 join 的阻塞示例
  ```c
  // file: ex_join_multi_block.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  enum { N = 5 };
  void* worker(void* arg) {
      int delay = (int)(long)arg; // 不同线程休眠不同时间
      sleep(delay);
      printf("thread delay=%d finished\n", delay);
      return (void*)(long)delay;
  }

  int main(void) {
      pthread_t tids[N];
      int delays[N] = {5, 1, 3, 2, 4}; // 0号最晚结束，顺序 join 会先阻塞在它上面
      for (int i = 0; i < N; ++i) {
          pthread_create(&tids[i], NULL, worker, (void*)(long)delays[i]);
      }
      // 顺序 join：如果 tids[0] 最晚结束，将阻塞，后面已结束的线程也无法及时回收
      for (int i = 0; i < N; ++i) {
          void* rv = NULL;
          pthread_join(tids[i], &rv);
          printf("joined i=%d, rv=%ld\n", i, (long)rv);
      }
      return 0;
  }
  ```
  - 说明：为避免阻塞影响其它已结束线程的回收，可采用 detached、tryjoin_np（非标准）或自定义完成通知等策略

- 示例 4：创建后由创建者分离（pthread_detach）
  ```c
  // file: ex_detach_creator.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("detached by creator, tid=%lu\n", (unsigned long)pthread_self());
      sleep(1);
      return NULL; // 退出即系统自动回收
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      int rc = pthread_detach(tid);
      if (rc != 0) printf("detach failed, rc=%d\n", rc);

      // 不能再对 tid 调用 pthread_join
      sleep(2); // 给子线程时间完成
      return 0;
  }
  ```

- 示例 5：线程自我分离
  ```c
  // file: ex_detach_self.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      pthread_detach(pthread_self()); // 自我分离
      printf("self-detached, tid=%lu\n", (unsigned long)pthread_self());
      sleep(1);
      return NULL; // 系统自动回收
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      // 不可 join；让主线程停留以便子线程完成
      sleep(2);
      return 0;
  }
  ```

- 示例 6：创建即分离（属性方式）
  ```c
  // file: ex_attr_detached.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("created as detached, tid=%lu\n", (unsigned long)pthread_self());
      sleep(1);
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_attr_t attr;
      pthread_attr_init(&attr);
      pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

      pthread_create(&tid, &attr, worker, NULL);
      pthread_attr_destroy(&attr); // 用完销毁属性对象

      // 不可 join；等待其完成以便观察输出
      sleep(2);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  # 推荐使用 -pthread（等价于链接 pthread 并设置线程相关编译选项）
  gcc -Wall -Wextra -O2 -pthread -o ex_ps_observe        ex_ps_observe.c
  gcc -Wall -Wextra -O2 -pthread -o ex_join_basic         ex_join_basic.c
  gcc -Wall -Wextra -O2 -pthread -o ex_join_multi_block   ex_join_multi_block.c
  gcc -Wall -Wextra -O2 -pthread -o ex_detach_creator     ex_detach_creator.c
  gcc -Wall -Wextra -O2 -pthread -o ex_detach_self        ex_detach_self.c
  gcc -Wall -Wextra -O2 -pthread -o ex_attr_detached      ex_attr_detached.c

  # 在另一个终端用 ps 观察（示例）
  ps -eLf | grep ex_ps_observe
  ```

- 小结
  - joinable 线程需 pthread_join 回收；pthread_join 是阻塞式。
  - detached 线程退出即系统自动回收，不可再 join；适合“只需运行完成、无需获取返回值/状态”的场景。
  - 可通过创建后 detach、自我分离或属性设为分离三种方式实现分离。
  - 多线程回收注意避免“顺序 join 被最慢线程阻塞”的问题；根据场景选 detach、tryjoin 扩展或自定义同步机制。


## 四、线程回收与取消：pthread_join、pthread_cancel、取消点与 gdb 调试

- 摘要
  - 演示了线程的创建与回收：pthread_create 创建，线程内 pthread_exit 退出，主线程用 pthread_join 回收并获取返回值。
  - 引出问题：线程若陷入死循环不主动退出，pthread_join 将一直阻塞，无法回收。
  - 线程取消：使用 pthread_cancel(tid) 取消目标线程，但必须满足“取消点”条件（如 sleep 等阻塞系统调用）。
  - 调试段错误：使用 gdb（编译加 -g，运行 gdb -> run -> bt）定位崩溃位置；示例中因被取消线程未返回值而错误打印导致段错误。


- 重点
  - 线程回收机制（pthread_join）
  - 线程取消操作（pthread_cancel）
  - 取消点的必要性（如 sleep）
  - 段错误调试方法（gdb：-g、run、bt）
  - 野指针与空指针引发的崩溃现象辨析（示例中为空指针导致的打印崩溃）

- 示例 1：正常创建与回收（线程主动退出）
  ```c
  // file: ex_join_ok.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("child: running, will exit after 5s\n");
      sleep(5);
      pthread_exit("child done"); // 返回值供主线程打印
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      void* ret = NULL;
      pthread_join(tid, &ret);
      printf("main: joined, retval=%s\n", (char*)ret);
      return 0;
  }
  ```

- 示例 2：线程死循环，join 无法回收
  ```c
  // file: ex_join_block.c
  #include <stdio.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("child: entering infinite loop\n");
      while (1) {} // 不主动退出
      // pthread_exit("never reached");
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      void* ret = NULL;
      // 将一直阻塞，因为子线程从不退出
      pthread_join(tid, &ret);
      printf("main: joined, retval=%s\n", (char*)ret);
      return 0;
  }
  ```

- 示例 3：pthread_cancel 取消线程（含取消点）；避免因返回值为空导致段错误
  ```c
  // file: ex_cancel.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      printf("child: running, sleeping in loop (cancellation point)\n");
      while (1) {
          sleep(1); // 取消点：阻塞调用
      }
      // 不会执行到这里
      // pthread_exit("child done");
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);

      // 给子线程一点时间进入 sleep（取消点）
      sleep(2);

      // 取消子线程
      pthread_cancel(tid);

      // 注意：被取消的线程没有正常的 pthread_exit 返回值
      // 若仍然尝试打印作为字符串，可能导致段错误（空指针）
      void* ret = NULL;
      pthread_join(tid, &ret);

      // 正确做法：不将 ret 当作 C 字符串使用；这里只打印指针值
      printf("main: thread canceled, retval=%p\n", ret);
      return 0;
  }
  ```

- 示例 4：无取消点时 pthread_cancel 不生效（移除 sleep）
  ```c
  // file: ex_cancel_no_point.c
  #include <stdio.h>
  #include <pthread.h>

  void* worker(void* arg) {
      (void)arg;
      // 没有阻塞调用 → 无取消点（默认延迟取消模式）
      while (1) { /* busy loop */ }
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);

      // 试图取消，但由于没有取消点，线程不会响应取消
      pthread_cancel(tid);

      // join 将一直阻塞（演示用，实际会卡住）
      void* ret = NULL;
      pthread_join(tid, &ret);
      return 0;
  }
  ```

- 用 ps 观察线程数量（示例程序运行中）
  ```bash
  ps -eLf | grep ex_cancel | grep -v grep
  ```

- gdb 调试段错误（示例流程）
  - 编译时加调试信息
    ```bash
    gcc -g -O0 -pthread -o ex_cancel ex_cancel.c
    ```
  - 进入 gdb 并运行程序
    ```bash
    gdb ./ex_cancel
    (gdb) run
    ```
  - 程序崩溃后（Segmentation fault）
    ```bash
    (gdb) bt        # 打印调用栈，定位出错函数/行
    ```
  - 分析
    - 示例中崩溃发生在 printf 打印线程返回值处；
    - 线程被 pthread_cancel 取消后，没有通过 pthread_exit 返回有效字符串，导致把空指针当字符串打印，引发段错误；
    - 解决：不要将取消后的返回值当作字符串使用，或直接不打印该返回值。

- 编译与运行
  ```bash
  # 正常创建与回收
  gcc -Wall -Wextra -O2 -pthread -o ex_join_ok ex_join_ok.c
  ./ex_join_ok

  # 死循环导致 join 阻塞（演示后 Ctrl+C 结束）
  gcc -Wall -Wextra -O2 -pthread -o ex_join_block ex_join_block.c
  ./ex_join_block

  # 带取消点的取消
  gcc -Wall -Wextra -O2 -pthread -o ex_cancel ex_cancel.c
  ./ex_cancel

  # 无取消点的取消失败（演示后 Ctrl+C 结束）
  gcc -Wall -Wextra -O2 -pthread -o ex_cancel_no_point ex_cancel_no_point.c
  ./ex_cancel_no_point

  # gdb 调试（以 ex_cancel 为例）
  gcc -g -O0 -pthread -o ex_cancel ex_cancel.c
  gdb ./ex_cancel
  ```


## 五、线程取消：取消点、pthread_testcancel、pthread_setcancelstate 与时序细节

- 摘要
  - 线程取消不是无条件的；只有在“取消点”处才会响应取消请求，典型取消点是阻塞的系统调用（如 sleep）。
  - 若代码中没有自然的取消点，可在适当位置调用 pthread_testcancel 手动设置取消点。
  - 可用 pthread_setcancelstate 控制一段代码期间是否允许被取消：PTHREAD_CANCEL_DISABLE（禁止取消）、PTHREAD_CANCEL_ENABLE（允许取消）。
  - 注意时序细节：创建线程后若立即在主线程调用取消，可能在线程尚未完成取消状态设置前就生效；可添加短暂延时，确保线程已设置完再取消。



- 重点
  - 线程取消的条件（需取消点） 00:08
  - 取消点的作用 11:14
  - 手动取消点：pthread_testcancel
  - 取消范围控制：pthread_setcancelstate
  - 时序细节：取消时机与必要延时

- 相关 API（本节涉及）
  - int pthread_cancel(pthread_t thread)
  - void pthread_testcancel(void)
  - int pthread_setcancelstate(int state, int* oldstate)
    - state 取值：PTHREAD_CANCEL_DISABLE 或 PTHREAD_CANCEL_ENABLE

- 示例 1：无阻塞调用场景下手动添加取消点
  ```c
  // file: ex_testcancel.c
  #include <stdio.h>
  #include <pthread.h>
  #include <unistd.h>

  void* worker(void* arg) {
      (void)arg;
      printf("worker: running without natural cancellation points\n");
      for (;;) {
          // ... 执行计算/轮询等非阻塞逻辑 ...
          pthread_testcancel(); // 手动取消点
      }
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);

      sleep(1);             // 给线程时间运行到取消点
      pthread_cancel(tid);  // 发出取消请求
      pthread_join(tid, NULL);
      printf("main: worker canceled via pthread_testcancel\n");
      return 0;
  }
  ```

- 示例 2：在关键区禁止取消，之后再允许取消
  ```c
  // file: ex_setcancelstate.c
  #include <stdio.h>
  #include <pthread.h>
  #include <unistd.h>

  void critical_work(void) {
      // 模拟关键区：不希望被取消打断
      for (int i = 0; i < 3; ++i) {
          printf("critical step %d\n", i);
          // 若这里没有阻塞调用，则不会自然形成取消点
      }
  }

  void* worker(void* arg) {
      (void)arg;

      // 禁止取消：确保关键区安全完成
      pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
      critical_work();

      // 允许取消：后续执行可被取消（需有取消点）
      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
      while (1) {
          printf("post-critical: sleeping (cancellation point)\n");
          sleep(1); // 取消点
      }
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);

      // 确保线程已完成取消状态设置（避免“创建即取消”带来的偶发行为）
      sleep(1);

      // 发出取消请求；由于已处于 ENABLE 且有取消点，线程将在 sleep 处响应
      pthread_cancel(tid);
      pthread_join(tid, NULL);
      printf("main: worker canceled after critical section\n");
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_testcancel       ex_testcancel.c
  gcc -Wall -Wextra -O2 -pthread -o ex_setcancelstate   ex_setcancelstate.c

  ./ex_testcancel
  ./ex_setcancelstate
  ```

- 补充（了解）
  - 可设置取消“类型”（延时/异步）。默认为延时取消（到取消点才生效）；异步取消则更及时（立即生效）。本节仅作了解，不展开。


## 六、线程清理与取消类型：pthread_cleanup_push/pop、资源释放、deferred/async cancel

- 摘要
  - 线程被取消（或异常退出）可能导致已申请资源（如 malloc）未释放，产生内存泄漏；应使用线程清理函数进行资源回收。
  - 清理函数通过 pthread_cleanup_push/pthread_cleanup_pop 注册/弹出，二者必须成对使用（为宏而非普通函数），否则会编译失败。
  - 清理函数触发条件：
    1) 线程被 pthread_cancel 取消（在取消点生效）；
    2) 线程执行 pthread_exit；
    3) 调用 pthread_cleanup_pop(非零) 时立即执行清理函数。
     若 pthread_cleanup_pop(0) 则只弹出而不执行。
  - return 退出线程不会触发已注册的清理函数；pthread_exit 会触发。
  - 线程可自我取消：pthread_cancel(pthread_self())；默认为延时取消（deferred），需要遇到取消点；可用 pthread_setcanceltype 设为异步取消（asynchronous）立即生效。

- 分段总结
  - 00:01 线程取消与内存泄漏
    - 正常退出能 free；取消导致未达释放处会泄漏，需要清理函数。
  - 01:33 线程清理概念
    - 清理函数签名：void cleanup(void* arg)；push/pop 成对使用。
  - 02:55 线程清理函数使用
    - 示例展示创建、取消、回收配合清理函数；常见编译错误多因括号/宏配对问题。
  - 11:29 清理函数触发条件
    - 取消/调用 pthread_exit/pthread_cleanup_pop(非零) 三种情况会执行。
  - 17:28 注意事项
    - push/pop 必须配对；pop 的参数决定是否执行清理函数。
  - 21:26 线程自我取消
    - pthread_self 获取自身 tid 自我取消；默认需取消点；可设为立即取消。
  - 26:29 其他要点
    - return 不触发清理；pthread_exit 的返回值可被 join 获取。

- 重点
  - 避免取消引发的资源泄漏：使用 pthread_cleanup_push/pop
  - push/pop 必须成对（宏展开涉及花括号，未配对会编译错误）
  - 清理函数三种触发条件
  - return 与 pthread_exit 的差异：仅后者触发清理
  - 延时取消与异步取消的区别与使用场景

- 相关 API（本节涉及）
  - void pthread_cleanup_push(void (*routine)(void*), void* arg)    // 宏
  - void pthread_cleanup_pop(int execute)                            // 宏
  - int  pthread_cancel(pthread_t thread)
  - void pthread_exit(void* retval)
  - pthread_t pthread_self(void)
  - int  pthread_setcanceltype(int type, int* oldtype)
    - type 取值：PTHREAD_CANCEL_DEFERRED（默认，需要取消点）/ PTHREAD_CANCEL_ASYNCHRONOUS（立即取消）

- 宏配对与编译错误提示
  - pthread_cleanup_push/pop 是宏，push 宏展开会引入“未闭合的 {”，对应的 “}” 在 pop 宏中补上。
  - 若只写 push 不写 pop，会出现类似 “expected … before …” 的语法错误，排查方向应首先检查 push/pop 是否配对。

- 示例 1：取消触发清理（防止泄漏）
  ```c
  // file: ex_cleanup_cancel.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>

  static void cleanup(void* p) {
      printf("cleanup: freeing %p\n", p);
      free(p);
  }

  void* worker(void* arg) {
      (void)arg;
      void* buf = malloc(1024);
      printf("worker: allocated %p\n", buf);

      pthread_cleanup_push(cleanup, buf); // 注册清理（必须与 pop 成对）

      while (1) {
          // 取消点：sleep 是阻塞调用（默认延时取消在此生效）
          sleep(1);
      }

      pthread_cleanup_pop(0); // 正常不执行（示例中不会到达）
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      sleep(2);                // 让子线程跑到取消点
      pthread_cancel(tid);     // 取消 -> 在取消点触发 cleanup
      pthread_join(tid, NULL); // 回收
      return 0;
  }
  ```

- 示例 2：pthread_exit 触发清理；return 不触发
  ```c
  // file: ex_cleanup_exit_vs_return.c
  #include <stdio.h>
  #include <pthread.h>

  static void cleanup(void* arg) {
      printf("cleanup executed: %s\n", (char*)arg);
  }

  void* by_exit(void* arg) {
      pthread_cleanup_push(cleanup, "from pthread_exit");
      pthread_exit("retval-exit");        // 触发 cleanup
      pthread_cleanup_pop(0);             // 不会执行到，但必须配对
      return NULL;
  }

  void* by_return(void* arg) {
      pthread_cleanup_push(cleanup, "from return");
      return "retval-return";             // return 不触发 cleanup
      pthread_cleanup_pop(0);             // 不会执行到，但必须配对
  }

  int main(void) {
      pthread_t t1, t2;
      void* rv = NULL;

      pthread_create(&t1, NULL, by_exit, NULL);
      pthread_join(t1, &rv);
      printf("joined by_exit, rv=%s\n", (char*)rv);

      pthread_create(&t2, NULL, by_return, NULL);
      pthread_join(t2, &rv);
      printf("joined by_return, rv=%s (no cleanup)\n", (char*)rv);
      return 0;
  }
  ```

- 示例 3：pthread_cleanup_pop 的 execute 参数
  ```c
  // file: ex_cleanup_pop_execute.c
  #include <stdio.h>
  #include <pthread.h>

  static void cleanup(void* arg) {
      printf("cleanup executed with arg=%s\n", (char*)arg);
  }

  void* worker(void* arg) {
      (void)arg;
      pthread_cleanup_push(cleanup, "A");
      pthread_cleanup_push(cleanup, "B");

      // 立即执行最近注册的清理函数（“B”）
      pthread_cleanup_pop(1);  // 执行 cleanup("B")
      // 仅弹出，不执行（“A”被移除且不执行）
      pthread_cleanup_pop(0);

      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      pthread_join(tid, NULL);
      return 0;
  }
  ```

- 示例 4：多个清理函数的执行顺序（栈：后进先出）
  ```c
  // file: ex_cleanup_stack_order.c
  #include <stdio.h>
  #include <pthread.h>
  #include <unistd.h>

  static void c1(void* _) { (void)_; printf("cleanup 1\n"); }
  static void c2(void* _) { (void)_; printf("cleanup 2\n"); }

  void* worker(void* arg) {
      (void)arg;
      pthread_cleanup_push(c1, NULL);
      pthread_cleanup_push(c2, NULL);

      // 触发路径：取消 -> 在 sleep 处生效
      sleep(10);

      pthread_cleanup_pop(0);
      pthread_cleanup_pop(0);
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      sleep(1);
      pthread_cancel(tid);     // 触发：输出顺序应为 cleanup 2 -> cleanup 1
      pthread_join(tid, NULL);
      return 0;
  }
  ```

- 示例 5：线程自我取消（默认延时取消需要取消点）
  ```c
  // file: ex_self_cancel_deferred.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  static void cleanup(void* _) { (void)_; printf("cleanup on self-cancel\n"); }

  void* worker(void* arg) {
      (void)arg;
      pthread_cleanup_push(cleanup, NULL);

      printf("self-cancel requested, waiting for cancellation point...\n");
      pthread_cancel(pthread_self()); // 发起对自身的取消请求（延时）
      // 必须遇到取消点才会真正结束
      sleep(1); // 取消点

      pthread_cleanup_pop(0);  // 不会到达
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      pthread_join(tid, NULL);
      return 0;
  }
  ```

- 示例 6：立即取消（异步取消）
  ```c
  // file: ex_self_cancel_async.c
  #include <stdio.h>
  #include <pthread.h>

  static void cleanup(void* _) { (void)_; printf("cleanup on async cancel\n"); }

  void* worker(void* arg) {
      (void)arg;
      pthread_cleanup_push(cleanup, NULL);

      // 设置为异步取消：取消请求立即生效（谨慎使用）
      pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
      pthread_cancel(pthread_self());

      // 若为异步取消，此行不应再执行
      printf("should not print (async)\n");

      pthread_cleanup_pop(0);
      return NULL;
  }

  int main(void) {
      pthread_t tid;
      pthread_create(&tid, NULL, worker, NULL);
      pthread_join(tid, NULL);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_cleanup_cancel            ex_cleanup_cancel.c
  gcc -Wall -Wextra -O2 -pthread -o ex_cleanup_exit_vs_return    ex_cleanup_exit_vs_return.c
  gcc -Wall -Wextra -O2 -pthread -o ex_cleanup_pop_execute       ex_cleanup_pop_execute.c
  gcc -Wall -Wextra -O2 -pthread -o ex_cleanup_stack_order       ex_cleanup_stack_order.c
  gcc -Wall -Wextra -O2 -pthread -o ex_self_cancel_deferred      ex_self_cancel_deferred.c
  gcc -Wall -Wextra -O2 -pthread -o ex_self_cancel_async         ex_self_cancel_async.c
  ```

- 小结
  - 在可能被取消的线程内，凡是“申请-释放”成对的资源（内存、文件描述符、锁等），尽量用 pthread_cleanup_push/pop 注册清理，确保异常退出也能回收。
  - push/pop 必须成对；pop(1) 立即执行最近注册的清理函数，pop(0) 仅移除不执行。
  - 取消触发清理、pthread_exit 触发清理；return 不触发清理。
  - 默认为延时取消（需取消点）；必要时才使用异步取消，注意其带来的不一致风险。



## 七、线程同步与互斥：临界资源/临界区、pthread_mutex 用法与示例

- 摘要
  - 临界资源：同一时刻只允许一个任务访问的共享资源（如文件、打印机、外设、磁盘等）。
  - 临界区：访问临界资源的那段代码。
  - 互斥锁（mutex）：用于保护临界区，保证同一时刻只有一个线程进入；类比“卫生间锁门”，占用者上锁，使用完解锁，后续等待者再进入。
  - Linux 下使用 pthread 库：pthread_mutex_init/destroy 初始化与销毁，pthread_mutex_lock/unlock 获取与释放，pthread_mutex_trylock 非阻塞尝试获取。
  - 实践效果：两个线程同时写同一文件，不加锁会“乱码”交错；加锁后内容规整。忙循环中用 usleep 让出 CPU，避免占满。


- 重点
  - 互斥机制（锁的获取/释放与等待）
  - 临界资源与临界区的识别
  - 静态初始化与动态初始化
  - 销毁锁的时机
  - 阻塞与非阻塞（trylock）
  - 忙循环中用 usleep 让出 CPU

- 核心概念
  - 临界资源：只能被一个线程独占使用的共享资源。
  - 临界区：对临界资源进行访问的代码片段，需要放在 lock/unlock 之间。
  - 互斥锁：进入临界区前加锁，退出后解锁；其他线程在锁被占用时阻塞（lock）或立即返回（trylock）。

- API 速览（pthread）
  - 初始化/销毁
    - int pthread_mutex_init(pthread_mutex_t* m, const pthread_mutexattr_t* attr);
    - int pthread_mutex_destroy(pthread_mutex_t* m);
    - 静态初始化：pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
  - 使用
    - int pthread_mutex_lock(pthread_mutex_t* m);      // 阻塞
    - int pthread_mutex_trylock(pthread_mutex_t* m);   // 非阻塞，忙时返回 EBUSY
    - int pthread_mutex_unlock(pthread_mutex_t* m);

- 互斥锁初始化方式
  - 静态初始化（简单常用）
    ```c
    pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;
    ```
  - 动态初始化（需要在运行时调用）
    ```c
    pthread_mutex_t g_lock;
    pthread_mutex_init(&g_lock, NULL);   // 默认属性
    // 使用完成后
    pthread_mutex_destroy(&g_lock);
    ```

- 示例 1：两个线程同时写同一文件（无锁，内容可能交错“乱码”）
  ```c
  // file: ex_mutex_nolock.c
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <pthread.h>

  typedef struct {
      FILE* fp;
      const char* line;
  } writer_arg_t;

  void* writer(void* arg) {
      writer_arg_t* a = (writer_arg_t*)arg;
      size_t n = strlen(a->line);
      for (int round = 0; round < 50; ++round) {         // 多轮写入以放大交错现象
          for (size_t i = 0; i < n; ++i) {
              fputc(a->line[i], a->fp);                  // 同一 FILE*，无锁
              usleep(1000);                              // 让出 CPU（微秒）
          }
          fputc('\n', a->fp);
      }
      return NULL;
  }

  int main(void) {
      FILE* fp = fopen("out_nolock.txt", "w");
      if (!fp) return 1;

      writer_arg_t a1 = { fp, "I am writer A line." };
      writer_arg_t a2 = { fp, "This is writer B line." };

      pthread_t t1, t2;
      pthread_create(&t1, NULL, writer, &a1);
      pthread_create(&t2, NULL, writer, &a2);

      pthread_join(t1, NULL);
      pthread_join(t2, NULL);

      fclose(fp);
      return 0;
  }
  ```

- 示例 2：为临界区加锁（内容规整）
  ```c
  // file: ex_mutex_lock.c
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;

  typedef struct {
      FILE* fp;
      const char* line;
  } writer_arg_t;

  void* writer(void* arg) {
      writer_arg_t* a = (writer_arg_t*)arg;
      size_t n = strlen(a->line);
      for (int round = 0; round < 50; ++round) {
          pthread_mutex_lock(&g_lock);            // 进入临界区
          for (size_t i = 0; i < n; ++i) {
              fputc(a->line[i], a->fp);
              usleep(1000);                       // 演示用：让出 CPU
          }
          fputc('\n', a->fp);
          pthread_mutex_unlock(&g_lock);          // 离开临界区
          usleep(1000);
      }
      return NULL;
  }

  int main(void) {
      FILE* fp = fopen("out_lock.txt", "w");
      if (!fp) return 1;

      writer_arg_t a1 = { fp, "I am writer A line." };
      writer_arg_t a2 = { fp, "This is writer B line." };

      pthread_t t1, t2;
      pthread_create(&t1, NULL, writer, &a1);
      pthread_create(&t2, NULL, writer, &a2);

      pthread_join(t1, NULL);
      pthread_join(t2, NULL);

      fclose(fp);
      // 若是动态初始化的锁，使用完应 pthread_mutex_destroy(&g_lock);
      return 0;
  }
  ```

- 示例 3：非阻塞尝试加锁（trylock）
  ```c
  // file: ex_mutex_trylock.c
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <errno.h>

  static pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;

  typedef struct {
      FILE* fp;
      const char* line;
  } writer_arg_t;

  void* writer(void* arg) {
      writer_arg_t* a = (writer_arg_t*)arg;
      size_t n = strlen(a->line);
      for (int round = 0; round < 50; ++round) {
          if (pthread_mutex_trylock(&g_lock) == 0) {  // 获取成功
              for (size_t i = 0; i < n; ++i) {
                  fputc(a->line[i], a->fp);
                  usleep(1000);
              }
              fputc('\n', a->fp);
              pthread_mutex_unlock(&g_lock);
          } else {
              // 未获取到锁：不阻塞，稍后再试或做其他工作
              usleep(1000);
          }
      }
      return NULL;
  }

  int main(void) {
      FILE* fp = fopen("out_trylock.txt", "w");
      if (!fp) return 1;

      writer_arg_t a1 = { fp, "AAA..." };
      writer_arg_t a2 = { fp, "BBB..." };

      pthread_t t1, t2;
      pthread_create(&t1, NULL, writer, &a1);
      pthread_create(&t2, NULL, writer, &a2);

      pthread_join(t1, NULL);
      pthread_join(t2, NULL);

      fclose(fp);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_mutex_nolock ex_mutex_nolock.c
  gcc -Wall -Wextra -O2 -pthread -o ex_mutex_lock   ex_mutex_lock.c
  gcc -Wall -Wextra -O2 -pthread -o ex_mutex_trylock ex_mutex_trylock.c

  ./ex_mutex_nolock   # out_nolock.txt 可能出现交错“乱码”
  ./ex_mutex_lock     # out_lock.txt 内容规整
  ./ex_mutex_trylock  # 非阻塞尝试，逻辑自行观察
  ```

- 小结
  - 识别临界资源与临界区，进入临界区前加锁、退出后解锁。
  - 静态初始化最简便；也可在运行时使用 pthread_mutex_init 动态初始化（默认属性传 NULL），结束时 pthread_mutex_destroy。
  - pthread_mutex_lock 为阻塞式获取；pthread_mutex_trylock 非阻塞，忙时立即返回。
  - 忙循环中适当 usleep 让出 CPU，避免占满。

## 八、读写锁（pthread_rwlock）：概念、特性、API 与示例

- 摘要
  - 互斥锁用于防止多个线程同时进入临界区，保证数据一致，但会把“读多写少”的场景也串行化，效率低。
  - 读写锁在读多写少时提升并发：允许多个读线程同时持有“读锁”；写线程需独占“写锁”，获取写锁时既不能有读者也不能有写者。
  - 典型特性：写锁需要“无人读、无人写”才可获得；读锁在“无人写”时可并行获得；一旦处于写锁状态，其他读/写都需等待。
  - 为避免写者长期饥饿：当有写者等待时，新来的读者会被阻塞，等写者完成后再放行（实现层面常见策略，课程中强调此效果）。

- 分段总结
  - 互斥锁的概念和用途
    - 串行化进入临界区，防止数据被并发破坏；写完再让别人写，保证完整性。
  - 读写锁的概念和用途
    - 读操作不改变数据，可并发读取；读多写少时以读写锁提升整体吞吐。
  - 读写锁的特性
    - 写锁：需“无读无写”方可加锁；同一时刻仅一个写者。
    - 读锁：只要“无写”，可有多个读者并行持有。
    - 写锁占用期间，其他读/写均阻塞。
    - 有写者等待时，新读者暂停进入，避免写者永远拿不到锁。
  - 读写锁使用方法
    - 初始化与销毁：pthread_rwlock_init / pthread_rwlock_destroy
    - 加/解锁：pthread_rwlock_rdlock（读锁）、pthread_rwlock_wrlock（写锁）、pthread_rwlock_unlock
  - 示例结果
    - 多读者可同时读取；写者需等待读者完成；整体对读密集场景效率提升明显。

- 重点
  - 读写锁的特性（多读并行、写者独占）
  - 与互斥锁区别（互斥锁完全串行；读写锁在无写时放大读并发）
  - 写者等待期间对新读者的限制（防止写者饥饿）
  - API 使用姿势（init/rdlock/wrlock/unlock/destroy）

- API 速览（pthread）
  - 初始化/销毁
    - int pthread_rwlock_init(pthread_rwlock_t* rwlock, const pthread_rwlockattr_t* attr);
    - int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);
  - 加/解锁
    - int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);     // 加读锁（阻塞）
    - int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);     // 加写锁（阻塞）
    - int pthread_rwlock_unlock(pthread_rwlock_t* rwlock);     // 解锁
    - 可选非阻塞版本（了解）：pthread_rwlock_tryrdlock / pthread_rwlock_trywrlock

- 示例 1：两个读线程并行读取，一个写线程独占写入
  ```c
  // file: ex_rwlock_basic.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_rwlock_t rwlock;

  // 共享资源（示意）：累加计数 + 一段文本
  typedef struct {
      int counter;
      char buf[256];
  } shared_t;

  static shared_t g = {0, "initial line"};

  void* reader(void* arg) {
      int id = (int)(long)arg;
      for (int round = 0; round < 3; ++round) {
          pthread_rwlock_rdlock(&rwlock); // 多读者可并行
          printf("[R%d] counter=%d, buf=%s\n", id, g.counter, g.buf);
          pthread_rwlock_unlock(&rwlock);
          usleep(200000); // 让出CPU，便于观察交错
      }
      return NULL;
  }

  void* writer(void* arg) {
      (void)arg;
      for (int round = 0; round < 3; ++round) {
          pthread_rwlock_wrlock(&rwlock); // 写者独占
          ++g.counter;
          snprintf(g.buf, sizeof(g.buf), "updated by writer, round=%d", round);
          printf("[W ] wrote: counter=%d, buf=%s\n", g.counter, g.buf);
          pthread_rwlock_unlock(&rwlock);
          usleep(300000);
      }
      return NULL;
  }

  int main(void) {
      pthread_rwlock_init(&rwlock, NULL);

      pthread_t r1, r2, w1;
      pthread_create(&r1, NULL, reader, (void*)(long)1);
      pthread_create(&r2, NULL, reader, (void*)(long)2);
      pthread_create(&w1, NULL, writer, NULL);

      pthread_join(r1, NULL);
      pthread_join(r2, NULL);
      pthread_join(w1, NULL);

      pthread_rwlock_destroy(&rwlock);
      return 0;
  }
  ```

- 示例 2：将读线程误用“写锁”对比（读被串行化）
  ```c
  // file: ex_rwlock_read_with_wrlock.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_rwlock_t rwlock;
  static int x = 0;

  void* reader_with_wrlock(void* arg) {
      int id = (int)(long)arg;
      pthread_rwlock_wrlock(&rwlock); // 误用：读也用写锁 → 读被串行化
      printf("[R%d] reading x=%d (holding WRLOCK)\n", id, x);
      usleep(200000);
      pthread_rwlock_unlock(&rwlock);
      return NULL;
  }

  int main(void) {
      pthread_rwlock_init(&rwlock, NULL);
      pthread_t r1, r2;
      pthread_create(&r1, NULL, reader_with_wrlock, (void*)(long)1);
      pthread_create(&r2, NULL, reader_with_wrlock, (void*)(long)2);
      pthread_join(r1, NULL);
      pthread_join(r2, NULL);
      pthread_rwlock_destroy(&rwlock);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_rwlock_basic            ex_rwlock_basic.c
  gcc -Wall -Wextra -O2 -pthread -o ex_rwlock_read_with_wrlock ex_rwlock_read_with_wrlock.c

  ./ex_rwlock_basic
  ./ex_rwlock_read_with_wrlock
  ```

- 小结
  - 读多写少时优先考虑读写锁：读锁允许并发、写锁严格独占。
  - 写者必须在“无读无写”时才能加锁；写者等待期间，新的读者应暂停进入，防止写者长期饥饿。
  - 与互斥锁相比，读写锁在无写者时显著提升读路径吞吐；正确区分 rdlock 与 wrlock，避免误把读路径串行化。



## 九、死锁：概念、成因、复现与避免（pthread）

- 摘要
  - 死锁是指多个线程/进程彼此等待对方持有的资源而无法继续执行的状态，典型表现为“互相堵住，谁也走不动”。
  - 程序中常见情形：至少两把锁，线程 A 先持有锁1再等锁2，线程 B 先持有锁2再等锁1，形成环形等待。
  - 一把锁时不会产生死锁（只有等待长短问题）；多把锁且加锁顺序不一致时，死锁概率显著上升。
  - 实践中可通过“时间错开”或“统一加锁顺序”避免死锁。

- 重点
  - 死锁的概念与表现
  - 多把锁、顺序不一致是高风险点
  - 两种实用避免策略：时间错开、统一加锁顺序

- 复现死锁的最小示例
  ```c
  // file: ex_deadlock_repro.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
  static pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;

  void* t1(void* arg) {
      (void)arg;
      pthread_mutex_lock(&m1);
      printf("[T1] got m1\n");
      sleep(1);                         // 放大竞态
      pthread_mutex_lock(&m2);          // 等 m2（此时可能被 T2 占用）
      printf("[T1] got both locks\n");
      pthread_mutex_unlock(&m2);
      pthread_mutex_unlock(&m1);
      return NULL;
  }

  void* t2(void* arg) {
      (void)arg;
      pthread_mutex_lock(&m2);
      printf("[T2] got m2\n");
      sleep(1);                         // 放大竞态
      pthread_mutex_lock(&m1);          // 等 m1（此时可能被 T1 占用）
      printf("[T2] got both locks\n");
      pthread_mutex_unlock(&m1);
      pthread_mutex_unlock(&m2);
      return NULL;
  }

  int main(void) {
      pthread_t a, b;
      pthread_create(&a, NULL, t1, NULL);
      pthread_create(&b, NULL, t2, NULL);
      pthread_join(a, NULL);
      pthread_join(b, NULL);
      return 0;
  }
  ```

  - 现象
    - 常见输出：
      - [T1] got m1
      - [T2] got m2
    - 然后卡住不动：T1 等 m2，T2 等 m1，形成死锁。

- 规避方法一：时间错开（安排执行先后）
  ```c
  // file: ex_deadlock_avoid_stagger.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
  static pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;

  void* t1(void* arg) {
      (void)arg;
      pthread_mutex_lock(&m1);
      printf("[T1] got m1\n");
      sleep(1);
      pthread_mutex_lock(&m2);
      printf("[T1] got both locks\n");
      // 模拟工作一段时间，再释放，给 T2 机会
      sleep(2);
      pthread_mutex_unlock(&m2);
      pthread_mutex_unlock(&m1);
      return NULL;
  }

  void* t2(void* arg) {
      (void)arg;
      // 主线程延时创建或先 sleep，确保 T1 已经拿齐锁并释放
      pthread_mutex_lock(&m2);
      printf("[T2] got m2\n");
      sleep(1);
      pthread_mutex_lock(&m1);
      printf("[T2] got both locks\n");
      pthread_mutex_unlock(&m1);
      pthread_mutex_unlock(&m2);
      return NULL;
  }

  int main(void) {
      pthread_t a, b;
      pthread_create(&a, NULL, t1, NULL);
      sleep(5);                  // 关键：错开启动时机，避免相互等待
      pthread_create(&b, NULL, t2, NULL);
      pthread_join(a, NULL);
      pthread_join(b, NULL);
      return 0;
  }
  ```

  - 思路
    - 通过延时让 T1 先完整持有并释放两把锁；随后 T2 再获取，避免环形等待。
    - 适用于演示与某些场景，但对复杂系统可维护性较差，依赖时序。

- 规避方法二：统一加锁顺序（推荐）
  ```c
  // file: ex_deadlock_avoid_order.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
  static pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;

  // 约定所有线程都按 m1 -> m2 的顺序加锁
  void* t1(void* arg) {
      (void)arg;
      pthread_mutex_lock(&m1);
      printf("[T1] got m1\n");
      sleep(1);
      pthread_mutex_lock(&m2);
      printf("[T1] got both locks\n");
      pthread_mutex_unlock(&m2);
      pthread_mutex_unlock(&m1);
      return NULL;
  }

  void* t2(void* arg) {
      (void)arg;
      pthread_mutex_lock(&m1);          // 遵循相同顺序（不再先拿 m2）
      printf("[T2] got m1\n");
      sleep(1);
      pthread_mutex_lock(&m2);
      printf("[T2] got both locks\n");
      pthread_mutex_unlock(&m2);
      pthread_mutex_unlock(&m1);
      return NULL;
  }

  int main(void) {
      pthread_t a, b;
      pthread_create(&a, NULL, t1, NULL);
      pthread_create(&b, NULL, t2, NULL);
      pthread_join(a, NULL);
      pthread_join(b, NULL);
      return 0;
  }
  ```

  - 思路
    - 全局制定并严格遵守统一的锁获取顺序（例如总是 m1→m2）。
    - 只要没有线程违反顺序，就不会出现“你等我，我等你”的环形等待。

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_deadlock_repro        ex_deadlock_repro.c
  gcc -Wall -Wextra -O2 -pthread -o ex_deadlock_avoid_stagger ex_deadlock_avoid_stagger.c
  gcc -Wall -Wextra -O2 -pthread -o ex_deadlock_avoid_order   ex_deadlock_avoid_order.c

  ./ex_deadlock_repro          # 观察卡住现象（死锁）
  ./ex_deadlock_avoid_stagger  # 通过时序错开避免
  ./ex_deadlock_avoid_order    # 通过统一加锁顺序避免
  ```

- 小结
  - 一把锁不会死锁；两把及以上锁、且不同线程获取顺序不一致时最危险。
  - 避免策略：
    - 优先减少锁数量，能用一把锁就不用两把；
    - 必须多锁时，统一加锁顺序；
    - 或在特定场景下通过时间错开安排执行顺序（演示与简易场景可用）。

