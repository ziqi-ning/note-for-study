# 线程管理10-13

## 十、条件变量：场景、原理、API 与生产者-消费者示例（pthread）

- 摘要
  - 条件变量用于“有条件才可继续”的线程协作典型场景，最常见为生产者-消费者：生产者随机地产生不可共享的资源，消费者在资源为空时等待。
  - 条件变量必须与互斥量一起使用：互斥量保护共享资源（临界资源），条件变量让“等待条件成立”的线程休眠并被唤醒，避免忙等。
  - 关键 API：pthread_cond_wait / pthread_cond_timedwait（等待），pthread_cond_signal / pthread_cond_broadcast（唤醒），配合 pthread_mutex_* 使用。
  - 核心流程：加锁→检查条件→不满足则在 cond_wait 中原子地解锁并休眠→被唤醒后重新加锁并复检→条件满足则访问资源→解锁。
- 重点
  - 条件变量的使用场景与与互斥量配合
  - wait/signal/broadcast 的作用与顺序
  - wait 必须在“已加锁且条件不满足”时调用，醒来后需再次检查条件
  - 链表队列式的资源生产与消费流程

- API 速览（pthread）
  - 初始化/销毁
    - int pthread_cond_init(pthread_cond_t* c, const pthread_condattr_t* a);
    - int pthread_cond_destroy(pthread_cond_t* c);
    - 静态初始化：pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
  - 等待/唤醒
    - int pthread_cond_wait(pthread_cond_t* c, pthread_mutex_t* m);
    - int pthread_cond_timedwait(pthread_cond_t* c, pthread_mutex_t* m, const struct timespec* abstime);
    - int pthread_cond_signal(pthread_cond_t* c);
    - int pthread_cond_broadcast(pthread_cond_t* c);
  - 互斥量（与条件变量配合）
    - pthread_mutex_init / destroy / lock / unlock

- 使用要点
  - pthread_cond_wait 必须在持有互斥量时调用；其内部会原子地“解锁并休眠”，被唤醒后会重新加锁返回。
  - 等待条件应使用 while 循环检查（条件不满足→wait；被唤醒后再复检），避免错误唤醒或状态变化导致的逻辑问题。
  - signal/broadcast 一般在“修改了共享状态并仍持锁”后调用，更容易保证等待方可见到最新状态。

- 示例 1：生产者-消费者（“出租车”链表）
  ```c
  // file: ex_cond_basic.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>

  typedef struct taxi {
      int number;
      struct taxi* next;
  } taxi_t;

  static taxi_t* head = NULL;                  // 链表头：最新产出的资源放在头部
  static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t  has_taxi = PTHREAD_COND_INITIALIZER;

  // 生产者：不断“产出出租车”并入队，然后 signal 通知
  void* producer(void* arg) {
      (void)arg;
      int i = 0;
      while (1) {
          taxi_t* t = (taxi_t*)malloc(sizeof(taxi_t));
          t->number = ++i;

          pthread_mutex_lock(&mtx);
          t->next = head;
          head = t;
          printf("[PROD] taxi %d arrived\n", t->number);

          pthread_cond_signal(&has_taxi);      // 有新资源，唤醒一个消费者
          pthread_mutex_unlock(&mtx);

          sleep(1);                            // 模拟随机到达
      }
      return NULL;
  }

  // 消费者：资源为空则等待，有则出队消费
  void* consumer(void* arg) {
      int id = (int)(long)arg;

      while (1) {
          pthread_mutex_lock(&mtx);
          while (head == NULL) {               // 条件不满足→等待
              pthread_cond_wait(&has_taxi, &mtx);
          }

          taxi_t* t = head;                    // 取头结点
          head = head->next;
          printf("[CONS-%d] take taxi %d\n", id, t->number);
          pthread_mutex_unlock(&mtx);

          free(t);                             // 消费完成释放资源
          // 模拟乘车用时
          usleep(200000);
      }
      return NULL;
  }

  int main(void) {
      pthread_t prod, cons1, cons2;
      pthread_create(&prod,  NULL, producer, NULL);
      pthread_create(&cons1, NULL, consumer, (void*)(long)1);
      pthread_create(&cons2, NULL, consumer, (void*)(long)2);

      pthread_join(prod,  NULL);
      pthread_join(cons1, NULL);
      pthread_join(cons2, NULL);
      return 0;
  }
  ```

- 示例 2：等待带超时（pthread_cond_timedwait）
  ```c
  // file: ex_cond_timedwait.c
  #include <stdio.h>
  #include <time.h>
  #include <pthread.h>

  static int ready = 0;
  static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t  cv  = PTHREAD_COND_INITIALIZER;

  void* waiter(void* arg) {
      (void)arg;
      pthread_mutex_lock(&mtx);

      struct timespec ts;
      clock_gettime(CLOCK_REALTIME, &ts);   // 绝对时间
      ts.tv_sec += 2;                       // 等待最多 2 秒

      while (!ready) {
          int rc = pthread_cond_timedwait(&cv, &mtx, &ts);
          if (rc == ETIMEDOUT) {
              printf("[WAIT] timed out waiting\n");
              break;
          }
      }

      if (ready) printf("[WAIT] observed ready=1\n");
      pthread_mutex_unlock(&mtx);
      return 0;
  }

  void* setter(void* arg) {
      (void)arg;
      // 故意延迟让 waiter 触发超时
      struct timespec ts = {.tv_sec = 3, .tv_nsec = 0};
      nanosleep(&ts, NULL);

      pthread_mutex_lock(&mtx);
      ready = 1;
      pthread_cond_signal(&cv);
      pthread_mutex_unlock(&mtx);
      return 0;
  }

  int main(void) {
      pthread_t t1, t2;
      pthread_create(&t1, NULL, waiter, NULL);
      pthread_create(&t2, NULL, setter, NULL);
      pthread_join(t1, NULL);
      pthread_join(t2, NULL);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_cond_basic      ex_cond_basic.c
  gcc -Wall -Wextra -O2 -pthread -o ex_cond_timedwait  ex_cond_timedwait.c

  ./ex_cond_basic
  ./ex_cond_timedwait
  ```

- 小结
  - 条件变量解决“条件满足前如何高效等待”的问题；与互斥量配合既保证资源独占又避免忙等。
  - 正确模式：加锁→while 检查→cond_wait（内部原子解锁并休眠）→醒来后重获锁并复检→执行→解锁。
  - signal 唤醒一个等待者；broadcast 唤醒所有等待者（例如有多个消费者需要被同时唤醒的场景）。




## 十一、条件变量进阶：signal/broadcast、丢失唤醒与“惊群效应”（pthread）

- 摘要
  - 条件变量用于生产者-消费者等“条件就绪才继续”的场景，与互斥量一起使用。
  - pthread_cond_signal 唤醒至少一个等待线程；pthread_cond_broadcast 唤醒所有等待线程。
  - 需要重点防范两类问题：
    1) 丢失唤醒（lost wakeup）：signal/broadcast 发生在 wait 之前，且没有等待者时，信号不会被“记账”，晚到的消费者将收不到此前的信号。
    2) “鲸群效应”（thundering herd）：broadcast 唤醒多消费者，若资源不足，未拿到资源的线程会再次睡眠；若代码不做条件判断，甚至可能出现空指针崩溃。
  - 正确模式：用“状态谓词 + 互斥量 + while 循环”来守护条件，生产者在持锁时修改状态并发送 signal/broadcast，消费者在持锁时 while(!条件) wait，醒来后复检。

- 关键概念回顾
  - 互斥量（mutex）：保护共享状态（临界资源）的并发访问。
  - 条件变量（condvar）：让线程在条件未满足时休眠、在条件满足时被唤醒。
  - cond_wait 的原子语义：在内部原子地“解锁并睡眠”，被唤醒后再“重新加锁并返回”。

- 丢失唤醒（lost wakeup）
  - 现象
    - 生产者先运行并多次 signal，消费者晚到，调用 cond_wait 前没有等待者，之前的 signal 全被丢弃；消费者只能在后续新的 signal 才被唤醒。
    - 示例现象：“前 5 辆出租车”已到且被 signal，但消费者晚 5 秒进入 wait，最终只从“第 6 辆”开始消费。
  - 根因
    - 条件变量不计数、无队列持久化；没有等待者时的 signal/broadcast 不会“积压”。
  - 正确做法（避免依赖时序）
    - 生产者：加锁→修改共享状态（如入队资源/设置标志）→在仍持锁时 signal/broadcast→解锁。
    - 消费者：加锁→while(条件未满足) cond_wait→条件满足后消费→解锁。
    - 该模式即便消费者晚到也不会错过：因为状态已被更新，消费者检查谓词后会直接跳过 wait。

- 广播与“鲸群效应”（pthread_cond_broadcast）
  - 现象
    - broadcast 会同时唤醒所有等待线程；在资源不足的情况下，只有少数线程能取到资源，其余线程在检查条件后应再次睡眠。
    - 若代码未用 while 守护条件（或未检查队列是否为空），可能发生空指针解引用崩溃。
  - 建议
    - 始终在消费者侧使用 while 复检条件，避免错误唤醒/资源抢空后的空指针。
    - 每次生产 1 个资源时，优先使用 pthread_cond_signal 唤醒 1 个等待者；仅在状态从“不可用→可用”（需要所有等待者都重新评估）或存在多份资源时考虑 broadcast。

- 调度与时序注意
  - 不要依赖“先 signal 后 wait / 先 wait 后 signal”的时序假设；用谓词+锁来保证正确性。
  - signal 通常在仍持有互斥量时调用，便于保证等待方醒来后能看到最新状态。
  - 醒来不等于条件满足，必须复检；不同消费者被唤醒/抢占的先后顺序不确定。

- 示例 1：丢失唤醒的复现（错误模式）
  ```c
  // file: ex_lost_wakeup_wrong.c
  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>

  static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t  cv  = PTHREAD_COND_INITIALIZER;
  // 没有显式的“状态谓词”，仅靠 signal/ wait 时序
  void* producer(void* _) {
      (void)_;
      for (int i = 1; i <= 5; ++i) {
          // 提前 signal（此时还没有等待者）
          pthread_mutex_lock(&mtx);
          printf("[PROD] signal %d\n", i);
          pthread_cond_signal(&cv);
          pthread_mutex_unlock(&mtx);
          sleep(1);
      }
      // 第 6 次后续才会被消费者捕捉到
      sleep(1);
      pthread_mutex_lock(&mtx);
      printf("[PROD] signal 6\n");
      pthread_cond_signal(&cv);
      pthread_mutex_unlock(&mtx);
      return NULL;
  }

  void* consumer(void* _) {
      (void)_;
      sleep(5); // 晚到：前 5 次 signal 无等待者 → 全部丢失
      pthread_mutex_lock(&mtx);
      printf("[CONS] waiting...\n");
      pthread_cond_wait(&cv, &mtx); // 只能等到“第 6 次”
      printf("[CONS] woke up\n");
      pthread_mutex_unlock(&mtx);
      return NULL;
  }

  int main(void) {
      pthread_t p, c;
      pthread_create(&p, NULL, producer, NULL);
      pthread_create(&c, NULL, consumer, NULL);
      pthread_join(p, NULL);
      pthread_join(c, NULL);
      return 0;
  }
  ```

- 示例 2：正确模式（谓词 + while，避免丢失唤醒）
  ```c
  // file: ex_cond_correct.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>

  typedef struct Node { int val; struct Node* next; } Node;
  static Node* head = NULL;                // 资源队列（出租车等）
  static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t  has_item = PTHREAD_COND_INITIALIZER;

  void* producer(void* _) {
      (void)_;
      for (int i = 1; i <= 6; ++i) {
          Node* n = (Node*)malloc(sizeof(Node));
          n->val = i;
          pthread_mutex_lock(&mtx);
          n->next = head; head = n;        // 修改共享状态
          pthread_cond_signal(&has_item);  // 仍持锁时 signal
          pthread_mutex_unlock(&mtx);
          sleep(1);
      }
      return NULL;
  }

  void* consumer(void* _) {
      (void)_;
      sleep(5);                            // 晚到
      for (int k = 0; k < 6; ++k) {
          pthread_mutex_lock(&mtx);
          while (head == NULL) {           // 必须 while 复检条件
              pthread_cond_wait(&has_item, &mtx);
          }
          Node* n = head; head = head->next;
          pthread_mutex_unlock(&mtx);
          printf("[CONS] got %d\n", n->val);
          free(n);
      }
      return NULL;
  }

  int main(void) {
      pthread_t p, c;
      pthread_create(&p, NULL, producer, NULL);
      pthread_create(&c, NULL, consumer, NULL);
      pthread_join(p, NULL);
      pthread_join(c, NULL);
      return 0;
  }
  ```

- 示例 3：broadcast 与“鲸群效应”（必须 while 复检）
  ```c
  // file: ex_broadcast_herd.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>

  typedef struct Node { int val; struct Node* next; } Node;
  static Node* head = NULL;
  static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t  has_item = PTHREAD_COND_INITIALIZER;

  void* producer(void* _) {
      (void)_;
      for (int round = 1; round <= 3; ++round) {
          // 每轮仅生产 1 个资源，但广播唤醒所有等待者
          Node* n = (Node*)malloc(sizeof(Node));
          n->val = round;
          pthread_mutex_lock(&mtx);
          n->next = head; head = n;
          pthread_cond_broadcast(&has_item); // 唤醒全部等待者
          pthread_mutex_unlock(&mtx);
          usleep(200000);
      }
      return NULL;
  }

  void* consumer(void* arg) {
      int id = (int)(long)arg;
      for (int t = 0; t < 3; ++t) {
          pthread_mutex_lock(&mtx);
          while (head == NULL) {                  // 关键：while 复检
              pthread_cond_wait(&has_item, &mtx);
          }
          // 多个线程被唤醒后，只允许一个线程成功取走
          Node* n = head; head = head->next;
          pthread_mutex_unlock(&mtx);
          printf("[C%d] got %d\n", id, n->val);
          free(n);
      }
      return NULL;
  }

  int main(void) {
      pthread_t p, c1, c2, c3;
      pthread_create(&p,  NULL, producer, NULL);
      pthread_create(&c1, NULL, consumer, (void*)(long)1);
      pthread_create(&c2, NULL, consumer, (void*)(long)2);
      pthread_create(&c3, NULL, consumer, (void*)(long)3);
      pthread_join(p,  NULL);
      pthread_join(c1, NULL);
      pthread_join(c2, NULL);
      pthread_join(c3, NULL);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -pthread -o ex_lost_wakeup_wrong ex_lost_wakeup_wrong.c
  gcc -Wall -Wextra -O2 -pthread -o ex_cond_correct      ex_cond_correct.c
  gcc -Wall -Wextra -O2 -pthread -o ex_broadcast_herd    ex_broadcast_herd.c

  ./ex_lost_wakeup_wrong     # 观察“只收到第 6 次”的丢失唤醒现象
  ./ex_cond_correct          # 即使消费者晚到也能消费已有资源
  ./ex_broadcast_herd        # 多消费者被唤醒，while 复检避免空指针/崩溃
  ```

- 小结
  - 条件变量不“记账”，没有等待者时的 signal/broadcast 会被丢弃；不要依赖时序，使用“谓词+互斥量+while 复检”的标准范式。
  - signal 唤醒一个等待者；broadcast 唤醒所有等待者，可能触发“惊群效应”，务必用 while 复检条件，必要时优先选择 signal。
  - 始终在持锁时修改共享状态并立即发出信号，确保等待者醒来后可见最新状态，避免空指针与竞争问题。


## 十二、线程池实现实战：数据结构、初始化/工作线程/提交任务/销毁与常见坑

- 摘要
  - 从零实现一个固定大小的线程池：先定义任务节点与线程池结构体，再分别实现初始化、工作线程主循环、添加任务与销毁逻辑。
  - 任务队列用链表管理；互斥量保护队列与状态；条件变量在“无任务时工作线程休眠/有任务时唤醒”间协调。
  - 实战中要警惕：拼写和头文件错误、pthread_* 接口参数遗漏、在休眠时持锁、过早 signal 造成丢失唤醒、提交端不做背压导致任务丢失或被视为“执行完”。


- 重点
  - 线程池的基本概念与结构（任务队列 + 工作线程 + 互斥量/条件变量）
  - 任务结构体与函数指针用法（函数与其参数一并封装）
  - 队列的入队/出队链表操作与加锁范围
  - 避免在休眠或执行任务时持锁；signal 要在持锁且状态已更新时发出
  - 常见实现坑与调试思路

- 数据结构与函数拆解
  - 任务节点（链表）
    - 包含函数指针和参数指针，next 指向下一个任务。
  - 线程池
    - 互斥量（锁队列与状态）、条件变量（队列非空信号）、线程ID数组、任务队列头/尾、线程数、关闭标志等。
  - 关键函数
    - init：初始化锁/条件变量/状态并创建 N 个工作线程
    - worker：while 循环等待任务，取出后在锁外执行任务函数
    - submit：创建任务并尾插入队，signal 唤醒工作线程；可选实现背压（队列容量/has_space）
    - destroy：置关闭标志、broadcast 唤醒、join 工作线程、清空队列与销毁同步原语

- 常见错误与排查
  - 拼写/头文件
    - pthread_cond_* 写成 pthread_count_*；malloc/ free 缺少 stdlib.h；pthread_mutex_init 少传属性参数（第二个参数可用 NULL）
  - 条件变量用法
    - wait 前必须先加锁；wait 内部会原子解锁并休眠，醒来后自动重新加锁；醒来要 while 复检条件
  - 信号丢失
    - 若 signal 早于 wait 且无等待者，唤醒不会“记账”；务必先更新状态（入队）并在持锁时 signal
  - 持锁休眠
    - 在 sleep/usleep 期间持锁会阻塞其他线程进入临界区，导致“看似卡死”
  - 没有背压
    - 提交端不限制队列容量，或仅用 busy 计数“节流”，易引发丢任务或误判完成；建议使用有界队列 + has_space/has_task 双条件变量

- 最小可运行示例（单文件、固定大小、链表队列）
  - 教学版简化实现，演示完整流程；生产中请参考 12 节的“有界队列+双条件变量”更稳健实现

- 入门版
```c name=thread_pool_simple.c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define POOL_NUM 10
typedef struct Task{
    void *(*func)(void *arg);
    void *arg;
    struct Task *next;
}Task;

typedef struct ThreadPool{
    pthread_mutex_t taskLock;
    pthread_cond_t newTask;

    pthread_t tid[POOL_NUM];
    Task *queue_head;
    int busywork;

}ThreadPool;

ThreadPool *pool;

void *workThread(void *arg){
    while(1){
        pthread_mutex_lock(&pool->taskLock);
        pthread_cond_wait(&pool->newTask,&pool->taskLock);

        Task *ptask = pool->queue_head;
        pool->queue_head = pool->queue_head->next;

        pthread_mutex_unlock(&pool->taskLock);

        ptask->func(ptask->arg);
        pool->busywork--;


    }


}

void *realwork(void *arg){
    printf("Finish work %d\n",(int)arg);

}

void pool_add_task(int arg){
    Task *newTask;
    
    pthread_mutex_lock(&pool->taskLock);
    while(pool->busywork>=POOL_NUM){
        pthread_mutex_unlock(&pool->taskLock);
        usleep(10000);
        pthread_mutex_lock(&pool->taskLock);
    }
    pthread_mutex_unlock(&pool->taskLock);
    

    newTask = malloc(sizeof(Task));
    newTask->func =  realwork;
    newTask->arg = arg;
    

    pthread_mutex_lock(&pool->taskLock);
    Task *member = pool->queue_head;
    if(member==NULL){
        pool->queue_head = newTask;
    }else{
       while(member->next!=NULL){
            member=member->next;
       }
       member->next = newTask;

    }
    pool->busywork++;
    pthread_cond_signal(&pool->newTask);

    pthread_mutex_unlock(&pool->taskLock);


}


void pool_init(){
    pool = malloc(sizeof(ThreadPool));
    pthread_mutex_init(&pool->taskLock,NULL);
    pthread_cond_init(&pool->newTask,NULL);
    pool->queue_head = NULL;
    pool->busywork=0;

    for(int i=0;i<POOL_NUM;i++){
        pthread_create(&pool->tid[i],NULL,workThread,NULL);
    }
}

void pool_destory(){
    Task *head;
    while(pool->queue_head!=NULL){
        head = pool->queue_head;
        pool->queue_head = pool->queue_head->next;
        free(head);
    }

    pthread_mutex_destroy(&pool->taskLock);
    pthread_cond_destroy(&pool->newTask);
    free(pool);

}
int main(){
   pool_init();
   sleep(20);
   for(int i=1;i<=20;i++){
       pool_add_task(i);

   }

   sleep(5);
   pool_destory();

}

```


- 进阶版
```c name=thread_pool_simple.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdatomic.h>

typedef struct task {
    void (*func)(void*);
    void* arg;
    struct task* next;
} task_t;

typedef struct thread_pool {
    pthread_mutex_t mtx;
    pthread_cond_t  has_task;

    pthread_t* tids;
    int        nthreads;

    task_t* head;
    task_t* tail;

    _Atomic int shutting_down;
} thread_pool_t;

// --------------- 内部工具 ---------------
static task_t* task_new(void (*f)(void*), void* a) {
    task_t* t = (task_t*)malloc(sizeof(task_t));
    if (!t) return NULL;
    t->func = f;
    t->arg  = a;
    t->next = NULL;
    return t;
}
static void task_free(task_t* t) { free(t); }

static void* worker(void* arg) {
    thread_pool_t* tp = (thread_pool_t*)arg;

    for (;;) {
        pthread_mutex_lock(&tp->mtx);
        while (!tp->shutting_down && tp->head == NULL) {
            pthread_cond_wait(&tp->has_task, &tp->mtx);
        }
        if (tp->shutting_down && tp->head == NULL) {
            pthread_mutex_unlock(&tp->mtx);
            break;
        }
        // 出队一个任务
        task_t* t = tp->head;
        tp->head = t->next;
        if (tp->head == NULL) tp->tail = NULL;
        pthread_mutex_unlock(&tp->mtx);

        // 在锁外执行
        t->func(t->arg);
        task_free(t);
    }
    return NULL;
}

// --------------- 对外 API ---------------
int tp_init(thread_pool_t* tp, int nthreads) {
    if (!tp || nthreads <= 0) return -1;
    tp->head = tp->tail = NULL;
    tp->nthreads = nthreads;
    tp->shutting_down = 0;

    if (pthread_mutex_init(&tp->mtx, NULL) != 0) return -1;
    if (pthread_cond_init(&tp->has_task, NULL) != 0) {
        pthread_mutex_destroy(&tp->mtx);
        return -1;
    }
    tp->tids = (pthread_t*)calloc((size_t)nthreads, sizeof(pthread_t));
    if (!tp->tids) {
        pthread_cond_destroy(&tp->has_task);
        pthread_mutex_destroy(&tp->mtx);
        return -1;
    }
    for (int i = 0; i < nthreads; ++i) {
        if (pthread_create(&tp->tids[i], NULL, worker, tp) != 0) {
            // 回滚
            atomic_store(&tp->shutting_down, 1);
            pthread_cond_broadcast(&tp->has_task);
            for (int j = 0; j < i; ++j) pthread_join(tp->tids[j], NULL);
            free(tp->tids);
            pthread_cond_destroy(&tp->has_task);
            pthread_mutex_destroy(&tp->mtx);
            return -1;
        }
    }
    return 0;
}

int tp_submit(thread_pool_t* tp, void (*func)(void*), void* arg) {
    if (!tp || !func) return -1;
    task_t* t = task_new(func, arg);
    if (!t) return -1;

    pthread_mutex_lock(&tp->mtx);
    if (tp->tail) tp->tail->next = t; else tp->head = t;
    tp->tail = t;
    // 在持锁状态下 signal，避免“状态不可见/丢失唤醒”
    pthread_cond_signal(&tp->has_task);
    pthread_mutex_unlock(&tp->mtx);
    return 0;
}

void tp_destroy(thread_pool_t* tp) {
    if (!tp) return;
    pthread_mutex_lock(&tp->mtx);
    atomic_store(&tp->shutting_down, 1);
    pthread_cond_broadcast(&tp->has_task);
    pthread_mutex_unlock(&tp->mtx);

    for (int i = 0; i < tp->nthreads; ++i) pthread_join(tp->tids[i], NULL);

    // 清空残余任务
    pthread_mutex_lock(&tp->mtx);
    task_t* cur = tp->head;
    while (cur) { task_t* nxt = cur->next; task_free(cur); cur = nxt; }
    tp->head = tp->tail = NULL;
    pthread_mutex_unlock(&tp->mtx);

    free(tp->tids);
    pthread_cond_destroy(&tp->has_task);
    pthread_mutex_destroy(&tp->mtx);
}

// --------------- 演示主程序 ---------------
static void work(void* arg) {
    int id = (int)(long)arg;
    printf("task %d start\n", id);
    usleep(100000); // 模拟短任务
    printf("task %d done\n", id);
}

int main(void) {
    thread_pool_t tp;
    if (tp_init(&tp, 10) != 0) {
        fprintf(stderr, "init failed\n");
        return 1;
    }

    // 提交 20 个任务；若担心“提交过快 + 消费过慢”，可在此处节流或使用有界队列
    for (int i = 1; i <= 20; ++i) {
        tp_submit(&tp, work, (void*)(long)i);
        // usleep(5000); // 可选节流，演示避免“看起来像丢任务”的错觉
    }

    sleep(2);  // 等待大致完成（生产中请用“任务计数+条件变量”）
    tp_destroy(&tp);
    return 0;
}
```

- 实战提醒
  - 若提交端过快、消费端较慢且你没有“有界队列+has_space”背压，可能误以为“任务没执行完”或“信号丢失”。本例用链表队列可承载任意数量任务，但内存会增长；建议在生产实现中采纳有界队列与双条件变量（has_task/has_space），配合 while 复检。
  - 需要严格区分“教学版简化”与“生产版稳健”：上一节提供了更完整的固定大小线程池（含队列容量与提交阻塞），可作为生产参考。


## 十三、多线程程序的 GDB 调试：显示/切换线程、断点、调度锁与单步

- 摘要
  - 通过一个包含两个子线程的简单示例，演示多线程程序在 GDB 下的基本调试流程：编译加 -g、设置断点、运行到断点、查看与切换线程、单步执行。
  - 重点讲解 set scheduler-locking 的作用：控制单步时是否只运行当前线程，避免其他线程“跟着跑”造成观测干扰。
  - 展示如何在特定线程上设置断点，配合 info threads 和 thread 命令进行线程级调试。



- 重点
  - 多线程调试三板斧：info threads（看）、thread N（切）、next/continue（走）
  - set scheduler-locking 的影响：控制单步时其他线程是否同时前进
  - 在指定线程设置断点，避免所有线程在同一行全部停住
  - 编译务必加 -g；断点建议设在可达位置（线程创建后）

- 常用命令速查
  - 编译与运行
    - gcc -g -O0 -pthread -o app app.c
    - gdb ./app
  - 断点
    - break file.c:LINE
    - break FUNCTION
    - break file.c:LINE thread THREAD_ID    // 在特定线程上设置断点
  - 运行与继续
    - run
    - continue
  - 查看线程与切换
    - info threads                          // 列出全部线程（GDB 内部线程号）
    - thread THREAD_ID                      // 切换当前线程
  - 单步与调度锁
    - next / step / finish
    - set scheduler-locking off|on|step     // 控制单步时其他线程是否运行
      - off：默认，其他线程也可能前进
      - on：仅当前线程前进
      - step：更严格，仅在单步/断点时限制
  - 其它
    - bt                                    // 回溯当前线程栈
    - thread apply all bt                   // 所有线程打印调用栈

- 示例流程（与视频一致的操作节奏）
  1) 设断点并运行
     - 在创建线程之后的行设置断点（例如 main 中 pthread_create 之后的行）
     - break app.c:5
     - run
  2) 查看线程列表
     - info threads
     - 观察 GDB 内部线程号（非 pthread_t），以及每个线程当前停驻位置
  3) 切到目标线程并单步
     - thread 3
     - next / step 观察该线程的输出与进度
     - 注意：未开启 scheduler-locking 时，其他线程可能也会继续执行并打印
  4) 锁定单步仅当前线程运行
     - set scheduler-locking on
     - thread 2; next；此时仅线程 2 前进，线程 3 停在原地
  5) 在特定线程设置断点
     - 先 run 到有线程后（否则没有线程可指定）
     - break app.c:6 thread 3
     - continue 让仅线程 3 在该位置停驻

- 常见坑
  - 未加 -g 导致无法按行断点（“No symbol table is loaded.”）
  - 在创建线程之前试图对“某线程”设断点（此时该线程尚不存在）
  - 未使用 scheduler-locking on 导致 next 时其他线程也悄然前进，输出顺序与预期不符
  - 线程结束后（join 回收），对应的 GDB 线程号会消失；info threads 可确认

- 小结
  - 多线程调试的本质是“先看清、再切换、再精确地走”。set scheduler-locking on 是让当前线程“独走”的关键。
  - 特定线程断点可大幅降低噪声，便于聚焦某一线程的执行路径与状态。
  - 结合 info threads、thread、break … thread N、next/step/continue，形成稳定的多线程调试套路。