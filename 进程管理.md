# 进程管理

## 一、进程概念

- 学习目标
  - 正确认知“程序 vs 进程”的区别（静态/动态、本体/运行态）
  - 理解进程包含的内存结构与进程控制块（PCB）
  - 熟悉常见进程类型与进程状态及其含义
  - 掌握与面试高频点相关的概念区分（BSS/数据段、堆/栈、RAM/ROM）

— 核心概念 —
- 程序（Program）
  - 定义：存放在磁盘上的指令与数据的集合，是静态的“文件实体”
  - 存储位置：ROM/非易失介质（如硬盘、SSD、闪存）
  - 组成（从“文件/镜像”的视角）：代码段、数据段、BSS 段等
- 进程（Process）
  - 定义：程序的“运行中的实例”，是动态的、活的
  - 存储位置：RAM/内存中进行运行与调度
  - 内容更丰富：除程序中的代码段和数据段，还包含“堆、栈、进程控制块”等运行期结构

— 程序 vs 进程（本质区别） —
- 静态 vs 动态：程序是“死的”文件，进程是“活的”执行态
- 存放位置：程序在 ROM（磁盘/闪存），进程在 RAM（内存）
- 包含内容：
  - 程序：代码段（text）、已初始化数据段（data）、未初始化数据段（bss）等
  - 进程：包含程序的上述段 + 堆（heap）+ 栈（stack）+ PCB（进程控制块）等运行期状态与元数据
- 数量关系：一个程序可被多次运行，形成多个独立进程实例（各自有独立地址空间与 PCB）

— 进程的内存与段结构 —
- 代码段（text/code）
  - 存放程序的机器指令（编译后产生的二进制代码）
- 已初始化数据段（data）
  - 存放已显式初始化的全局/静态变量
- 未初始化数据段（bss）
  - 存放未初始化的全局/静态变量（运行前会被置零）
- 堆（heap）
  - 动态内存区域（如 C 语言的 malloc/free）
  - 生命周期由程序员/运行库管理，适合动态大小、跨函数/长生命周期数据
- 栈（stack）
  - 函数调用栈帧：局部变量、函数参数、返回地址/返回值等
  - 生命周期与作用域受调用关系约束，自动分配/回收，空间相对有限
- 注意
  - static 变量属于静态存储期，位于数据段或 BSS 段，不在栈中
  - 堆与栈都是在内存中，但分配/增长方向、生命周期与使用方式不同

— 进程控制块（PCB，Process Control Block）—
- 作用：操作系统用于“描述和管理进程”的核心数据结构
- 常见字段（举例，具体以系统实现为准）
  - PID（进程标识符）、所属用户/用户组（UID/GID）
  - 进程状态（运行/等待/停止/僵尸等）
  - 优先级、调度相关信息、时间片等
  - CPU 上下文（寄存器现场等，用于进程切换）
  - 内存管理信息（代码段/数据段/堆/栈的范围，页表等）
  - 文件描述符表（打开文件/管道/套接字等资源的编号与指向）

— 进程类型（Linux 常见三类）—
- 交互进程（Interactive Process）
  - 在终端/shell 启动，通常以前台运行，可用 Ctrl+C 中断
- 批处理进程（Batch Process）
  - 常见于作业队列/脚本按序执行，不直接在终端交互
- 守护进程（Daemon）
  - 后台长期运行、与终端无关，不能通过 Ctrl+C 直接终止；常用于服务/系统后台任务

— 进程状态（常见）—
- 运行态（Running）
  - 正在 CPU 上执行；真正消耗 CPU 时间
- 等待/阻塞态（Waiting/Blocked）
  - 等待 CPU 或其他资源（I/O、锁、事件等）；不占用 CPU
- 停止态（Stopped）
  - 暂停执行（如被信号暂停），不占用 CPU
- 僵尸态（Zombie）
  - 进程已终止但尚未被其父进程回收（保留少量信息，如退出码/PID，等待父进程 wait/回收）
- 提示
  - 真实系统中还可区分“就绪态”等更细粒度状态，这里保留课程重点表述

— RAM vs ROM（内存 vs 磁盘/闪存）—
- 进程在 RAM 中运行，参与调度与上下文切换
- 程序/可执行文件/镜像存放于 ROM（如硬盘/SSD/Flash），作为“启动材料”
- 面试高频混淆点：不要把“手机 64G”当成内存（那是闪存容量），内存对应 RAM（运行内存）

— 面试高频要点与易错点 —
- 区分 BSS vs 数据段：是否“已初始化”的全局/静态变量
- 区分 堆 vs 栈：分配方式、生命周期、用途与存储内容
- 区分 程序 vs 进程：静态文件 vs 运行实例；ROM vs RAM
- 僵尸态含义：已“死”未“收”，需父进程 wait 回收
- PCB 的关键作用：是 OS 管理进程的一切“账本”

— 简要图示（文字化）—
- 程序（磁盘/ROM）：
  - [text] 代码段 | [data] 已初始化数据 | [bss] 未初始化数据 | …（静态镜像）
- 进程（内存/RAM）：
  - [text][data][bss]（自程序映射而来）+ [heap] + [stack] + [PCB/内核态结构] + …（动态运行期结构）

— 可选：常用命令速查（理解进程更直观，非课程原文必需）—
- 查看进程：ps aux、top/htop、pstree
- 发送信号：kill/killall（如 Ctrl+C 等价于向前台进程组发送 SIGINT）
- 查看文件描述符：ls -l /proc/<PID>/fd
- 回收子进程：父进程调用 wait/waitpid

— 小结 —
- 程序是“静态的存档”，进程是“动态的运行态”
- 进程比程序多出堆、栈与 PCB 等运行期结构
- 正确认知段结构与 PCB 字段，对定位问题与面试答题都很关键


## 二、进程的查看与管理

- 学习目标
  - 认识 ps（快照）与 top（实时）两大类进程观察工具
  - 熟悉 ps 常见选项与列的含义、top 的交互按键
  - 掌握按名称/按 PID 精确查找进程与查看 /proc 详情
  - 学会调整进程“友好度”（nice）与运行优先级（renice）
  - 理解前台/后台/挂起（Stopped）与常见作业控制命令（jobs/fg/bg/&）
  - 能定位 CPU/MEM 占用、进程状态、PID/PPID 等关键信息

— 基础概念 —
- 进程是程序的运行载体；Linux 下常用命令行工具进行观测与管理
- ps：获取“当前时刻”的进程快照（一次性输出）
- top：实时刷新显示进程信息（默认每 1-3 秒刷新）
- PID（进程号）是定位与操作进程的关键标识
- 常见指标：状态（STAT/STATE）、优先级（PR/PRI，NI）、CPU 利用率（%CPU）、内存（%MEM、RSS/VSZ）

— ps：查看进程快照 —
- 常用选项组合
  - ps                仅显示与当前 shell 相关的进程
  - ps -e             显示系统全部进程（等价于 -A）
  - ps -ef            全格式（full-format）显示所有进程
  - ps -elf           all + long + full，显示更详细列（在 GNU ps 支持下常见）
  - ps -eo <cols>     自定义列；配合 --sort 排序更灵活
- 常见列含义（不同格式会略有差异）
  - PID：进程号；PPID：父进程号
  - STAT/STATE：进程状态
    - R 运行中（Running），S 可中断睡眠（Sleeping），D 不可中断睡眠（I/O 等待）
    - T 停止（Stopped，常见于 Ctrl+Z），Z 僵尸（Zombie）
    - 其他标志：+ 前台进程组；< 高优先级；N 低优先级（nice 值高）
  - PRI/PR：动态优先级；NI：nice 值（-20..19，值越大越“nice”，优先级越低）
  - %CPU、%MEM：CPU/内存比例；VSZ（虚拟内存 KiB）、RSS/RES（常驻集 KiB）
  - TIME/C：累计 CPU 时间；START/ELAPSED：启动/已运行时长
  - COMMAND/CMD：启动命令（可能含参数）
- 示例
```bash
ps -ef | grep nginx
ps -elf | less
ps -eo pid,ppid,stat,ni,pri,pcpu,pmem,rss,vsz,etime,comm --sort=-pcpu | head
ps -C sshd -o pid,cmd        # 按可执行名筛选
```

— top：实时查看进程 —
- 基本用法
  - top                 实时刷新进程信息
  - top -p <PID>        只观察指定 PID
  - top -u <USER>       只观察某用户进程
- 常用交互按键（进入 top 后按键）
  - q 退出；h 帮助
  - 1 显示每核 CPU 使用率
  - P/M 以 CPU/内存占用排序；T 以时间排序
  - k 发送信号（kill）给进程；r 调整进程 nice（renice）
  - < > 翻页（部分系统需 Shift+< / Shift+>）
  - f 选择显示字段；o/O 调整排序字段
- 典型排查流程
  - 先 top 定位高 %CPU/%MEM 的 PID → k/r 进行管理 → 结合 ps -p 与 /proc 深入分析

— 精确查找与过滤 —
```bash
# 通过 ps/grep
ps -ef | grep '[m]ysqld'      # 避免 grep 自身匹配
# 推荐：pgrep/pidof（更稳健）
pgrep -a mysqld               # 列出 PID 和命令
pidof mysqld                  # 仅 PID
# 树形查看父子关系
pstree -ap | less
```

— /proc 进程详情（procfs）—
- /proc/<PID>/ 目录下是该进程的“内核视图”
  - cmdline     启动命令（NUL 分隔）
  - environ     环境变量（NUL 分隔）
  - status      关键信息汇总（状态、内存、权限、Cap 等）
  - stat        进程统计；statm 内存统计
  - fd/         打开的文件描述符（软链接，利于追踪文件/套接字）
  - limits      资源限制；maps/smaps 内存映射与占用
```bash
tr '\0' ' ' < /proc/<PID>/cmdline
ls -l /proc/<PID>/fd
cat /proc/<PID>/status | less
```

— 调整优先级：nice 与 renice —
- nice 值范围：-20（最高优先）.. 19（最低）
  - 值越大，进程越“nice”，越不争抢 CPU，调度优先级越低
- 权限约束
  - 普通用户：只能提高 nice（把数值调大），且仅能操作自己进程
  - root：可将 nice 设为负值（提升优先级）
- 命令
```bash
# 以较低优先级（更“友好”）启动新程序
nice -n 10 myscript.sh

# 调整已运行进程的优先级（将 nice 改为 5）
renice -n 5 -p <PID>

# 提升优先级（需要 root）
sudo renice -n -5 -p <PID>
```
- top 内交互调整
  - 在 top 中按 r 输入 PID 与新 nice 值

— 前台/后台与作业控制（Job Control）—
- 基础按键
  - Ctrl+C 发送 SIGINT：终止前台进程
  - Ctrl+Z 发送 SIGTSTP：暂停（Stopped）并挂起为作业
- 命令
```bash
jobs                 # 查看当前 shell 的后台作业
fg %1                # 将编号为 1 的作业恢复到前台
bg %1                # 让编号为 1 的作业在后台继续运行
cmd &                # 启动即在后台运行
kill %1              # 对作业发送信号（等价于对该作业的进程组）
```
- 进阶要点
  - 后台作业仍与终端关联，关闭终端会触发 SIGHUP
  - 持久化后台运行：nohup cmd &、disown、或 setsid
```bash
nohup cmd >out.log 2>&1 &
disown -h %1               # 使作业不再受 SIGHUP 影响
setsid cmd &               # 脱离控制终端新会话
```

— 进程状态与指标速览 —
- 常见状态（STAT）
  - R 运行，S 休眠，D 不可中断睡眠（多为 I/O 等待），T 停止（Ctrl+Z），Z 僵尸
- 优先级与友好度
  - PR/PRI 为动态优先级；NI 为 nice 值（-20..19）
- 内存列
  - VSZ（虚拟内存大小）/ RSS/RES（常驻内存）/ %MEM（内存比例）
- CPU
  - %CPU 为采样期间的占用；睡眠进程通常为 0

— 常见实战范式 —
```bash
# 1) 找出 CPU 占用最高的若干进程
ps -eo pid,ppid,ni,pri,pcpu,pmem,comm --sort=-pcpu | head

# 2) 实时盯住某个进程
top -p <PID>

# 3) 查进程打开了哪些文件/端口（需安装 lsof）
lsof -p <PID> | less

# 4) 仅看某类服务
pgrep -a 'nginx|mysql|redis'

# 5) 将前台进程挂起→后台运行→再切回前台
<运行前台进程>
Ctrl+Z
bg %1
fg %1
```

— 易错点与建议 —
- ps 输出“少”的原因
  - 仅执行 ps 无参数只列出与当前终端相关的进程；用 -e/-ef 查看全量
- grep 自身被匹配
  - 用 pgrep/pidof，或 grep '[n]ginx' 规避
- nice 与优先级方向
  - nice 数值越大，优先级越低；负值需要 root
- 后台作业与退出终端
  - 关闭终端会发 SIGHUP 终止作业；使用 nohup/disown/setsid 持久化
- top 排序与翻页
  - P/M 切换排序，< > 翻页（部分系统需配合 Shift）

— 小结 —
- ps 获取快照、top 实时监控是日常排障必备
- PID/状态/优先级/CPU/MEM 是排查重点
- 合理使用 nice/renice 管理 CPU 竞争
- 掌握作业控制与后台运行，避免终端关闭导致任务中断


## 三、创建子进程、父子关系与结束

- 学习目标
  - 掌握使用 fork 创建子进程及其返回值语义
  - 正确认知父子进程的执行模型与调度顺序（不可控、由内核决定）
  - 理解父子进程的继承与独立性、孤儿进程与僵尸进程的成因与处理
  - 会用常见命令辨识/结束进程，初步掌握回收子进程的方法

— 核心概念 —
- 进程与并发编程要点
  - 进程是程序的运行实例，具有动态性与并发性
  - 进程编程三要点：创建子进程、父子关系、结束与回收
- 子进程（Child Process）
  - 由父进程通过系统调用创建的进程
  - 子进程在逻辑上“继承”父进程的大量属性（打开文件、环境、信号处理方式等），但具备独立的执行流与地址空间

— 使用 fork 创建子进程 —
- 原型与作用
  - pid_t fork(void);
  - 作用：创建一个与调用者几乎相同的新进程
- 返回值语义（区分父/子）
  - 父进程中：返回新建子进程的 PID（> 0）
  - 子进程中：返回 0
  - 失败：只在调用者处返回 -1，且不产生子进程（常因资源不足/进程数上限）
- 执行模型
  - 成功后产生两个并发执行的进程，二者从 fork 调用点“之后”继续执行
  - 区分父子分支的典型写法：
    ```c
    pid_t pid = fork();
    if (pid > 0) {
        // 父进程分支
    } else if (pid == 0) {
        // 子进程分支
    } else {
        // fork 失败
    }
    ```
  - 父子谁先执行完全由内核调度决定，不可依赖顺序

— 父子进程的关系与特性 —
- 继承与独立
  - 子进程复制父进程的地址空间与大部分进程属性（现代实现采用写时复制 COW 优化）
  - 父子地址空间相互独立：一方修改变量不影响另一方
- PID 与 PPID
  - 每个进程有 PID，且持有其父进程号 PPID
  - 可用 ps -elf 等查看 PID/PPID 关系，辨识父子
- 常见易错点
  - fork 后 printf 语句可能出现重复打印：这是因为父子各自执行同一段代码
  - 若在 fork 前标准输出处于缓冲未刷新状态，缓冲区内容也可能被“复制”导致意外重复输出
    - 规避：在 fork 前 fflush(NULL) 或将 stdout 设为行缓冲/无缓冲

— 孤儿进程与僵尸进程 —
- 孤儿进程（Orphan）
  - 父进程先于子进程退出，子进程会被 PID 1（init/systemd）收养
  - 子进程成为后台进程，与原控制终端解除关系（Ctrl+C 无法直接终止）
- 僵尸进程（Zombie，defunct）
  - 子进程已退出，但父进程尚未 wait/waitpid 回收其退出状态，子进程残留为僵尸
  - 僵尸不再占用 CPU，但会占用 PID 等内核表项资源；应及时回收
- 回收子进程（预告/要点）
  - 父进程应调用 wait()/waitpid() 以获取子进程退出码并释放其内核资源
  - 典型写法（非阻塞回收）：
    ```c
    #include <sys/wait.h>
    int status;
    while (waitpid(-1, &status, WNOHANG) > 0) {
        // 回收所有已退出的子进程
    }
    ```
  - 其他策略：安装 SIGCHLD 处理器、双重 fork 等

— 结束进程与常见信号（速览）—
- 正常结束
  - 从 main 返回、调用 exit(int)、或在子进程中使用 _exit(int)
- 常见信号与键盘操作
  - Ctrl+C → SIGINT（终止前台进程）
  - Ctrl+Z → SIGTSTP（暂停，进入作业控制的 Stopped）
  - kill 发送信号：kill -TERM <PID>（优雅终止）、kill -KILL <PID>（强制终止）
- 命令行排查与控制
  - 查看进程：ps -elf | grep <name>，top，pgrep -a <name>
  - 查看父子关系：ps 输出中的 PID/PPID 列
  - 结束进程：kill [-SIGNAL] <PID>；强制：kill -9 <PID>

— 示例片段（课堂场景浓缩）—
- 基本 fork 判别父子：
  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <sys/types.h>

  int main(void) {
      pid_t pid = fork();
      if (pid > 0) {
          printf("Parent: child pid=%d\n", pid);
      } else if (pid == 0) {
          printf("Child: pid=0 branch\n");
      } else {
          perror("fork");
          return 1;
      }
      printf("After fork: runs in both\n");
      return 0;
  }
  ```
- 观察父先终止形成孤儿、由 PID 1 收养：
  - 父进程退出；ps -elf | grep <prog> 观察子进程的 PPID 变为 1
  - 子进程成为后台，Ctrl+C 不再直接终止它
- 观察子先终止形成僵尸：
  - 子进程快速退出，父进程不 wait → ps 显示 defunct
  - 回收方式：父进程调用 wait()/waitpid()，或父进程退出（由 PID 1 接管并回收其子）

— 实践建议 —
- 任何依赖“父子先后顺序”的代码都是脆弱的；用同步/等待原语（如 wait/信号/管道/IPC）保证次序
- 在 fork 前刷新 I/O 缓冲，避免重复输出副作用
- 对长期运行的父进程，务必设计子进程的回收路径（SIGCHLD 处理器 + 非阻塞 waitpid 循环）
- 禁用“滥用 kill -9”：优先尝试优雅终止（SIGTERM），必要时再强制

— 常用命令与观察手段（速记）—
- 全量进程：ps -e / ps -ef / ps -elf
- 按名过滤：ps -ef | grep '[n]ame' / pgrep -a name
- 观察父子：关注 PID/PPID 列
- 实时监控：top（或 top -p <PID>）
- 结束进程：kill -TERM <PID>；强制：kill -9 <PID>

— 面试高频点 —
- fork 返回值细节与分支判别
- 为什么会有“重复打印”？缓冲复制与父子各自执行
- 僵尸产生原因与回收手段（wait/waitpid、SIGCHLD、双重 fork）
- 孤儿进程的收养者（PID 1：init/systemd）
- 父子执行顺序与调度不可控，如何实现有序/同步


## 四、fork 多子进程：避免“孙进程”、生成不同拓扑与回收

- 学习目标
  - 理解为何“for 循环 + fork”会意外产生“孙进程”
  - 掌握只由同一父进程创建 N 个子进程（兄弟进程）的正确写法
  - 实现链式拓扑（父→子→孙→…）与树形拓扑（分叉）的通用范式
  - 正确回收子进程，避免僵尸；注意 I/O 缓冲与退出语义

— 为什么会出现“孙进程” —
- 现象根因：fork 成功后，父子进程都会从 fork 返回点继续执行。
  - 若直接在 for 循环里 fork 而子进程不“跳出循环/退出”，子进程也会继续执行 for，于是它自己也在循环中 fork，导致出现“孙进程”甚至“曾孙进程”。
- 解决核心：确保只有“父进程”继续循环创建，子进程在分支里尽快 break 或 _exit 结束，不再回到 for 循环。

— 正确创建 N 个“同一父进程的子进程”（兄弟结构）—
- 范式 A：子分支立即退出（推荐，最简洁）
```c
// siblings.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    setvbuf(stdout, NULL, _IONBF, 0); // 防止缓冲复制导致重复输出
    const int N = 5;
    pid_t pids[N];

    for (int i = 0; i < N; i++) {
        pid_t pid = fork();
        if (pid < 0) {
            perror("fork");
            // 可选择回收已创建的子进程再退出
            for (int k = 0; k < i; k++) waitpid(pids[k], NULL, 0);
            exit(1);
        }
        if (pid == 0) {
            // 子进程路径：执行自己的工作，不再回到 for 循环
            printf("[child #%d] pid=%d ppid=%d\n", i, getpid(), getppid());
            // ... 子进程工作 ...
            _exit(0); // 子进程使用 _exit，避免执行父进程的缓冲/清理逻辑
        }
        // 父进程路径：记录子 PID 并继续下一轮循环
        pids[i] = pid;
    }

    // 父进程回收所有子进程，避免僵尸
    for (int i = 0; i < N; i++) {
        waitpid(pids[i], NULL, 0);
    }
    printf("[parent] all children reaped, pid=%d\n", getpid());
    return 0;
}
```
- 范式 B：子分支 break 跳出循环（也可行）
```c
// siblings_break.c（要点相同，只是用 break 代替 _exit）
if (pid == 0) {
    printf("[child #%d] pid=%d ppid=%d\n", i, getpid(), getppid());
    // 子进程跳出 for，确保不再创建新的进程
    break;
}
```
- 验证
  - pstree -ap <父PID> 可视化应看到 1 个父 + N 个同级子（无孙）
  - ps -o pid,ppid,stat,cmd -p <PIDs> 查看 PPID 是否一致

— 链式拓扑：父→子→孙→…（线性深度 D）—
- 思路：只有子进程继续循环，父进程在创建后停止继续派生（break）；或反过来“父停、子续”。
```c
// chain.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    setvbuf(stdout, NULL, _IONBF, 0);
    const int DEPTH = 5; // 总进程数为 DEPTH
    for (int gen = 0; gen < DEPTH - 1; gen++) {
        pid_t pid = fork();
        if (pid < 0) { perror("fork"); exit(1); }
        if (pid > 0) {
            // 父进程：可选择等待直接子进程（让链有序退出）
            waitpid(pid, NULL, 0);
            printf("[gen=%d parent] pid=%d child=%d done\n", gen, getpid(), pid);
            break; // 父不再继续派生，链条只在子分支向下延伸
        } else {
            // 子进程继续向下派生
            printf("[gen=%d child ] pid=%d ppid=%d\n", gen+1, getpid(), getppid());
            // 循环继续
        }
    }
    // 最末端子进程自然结束
    return 0;
}
```

— 树形拓扑：每层分叉（示例：二叉树，深度限制）—
- 注意：进程数指数增长，务必限制深度并回收子进程。
```c
// tree.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void spawn_tree(int depth, int max_depth) {
    if (depth >= max_depth) return;

    pid_t left = fork();
    if (left < 0) { perror("fork"); exit(1); }
    if (left == 0) {
        printf("[depth=%d L] pid=%d ppid=%d\n", depth+1, getpid(), getppid());
        spawn_tree(depth + 1, max_depth);
        _exit(0);
    }

    pid_t right = fork();
    if (right < 0) { perror("fork"); exit(1); }
    if (right == 0) {
        printf("[depth=%d R] pid=%d ppid=%d\n", depth+1, getpid(), getppid());
        spawn_tree(depth + 1, max_depth);
        _exit(0);
    }

    // 父节点回收两个子节点，避免僵尸
    waitpid(left, NULL, 0);
    waitpid(right, NULL, 0);
}

int main(void) {
    setvbuf(stdout, NULL, _IONBF, 0);
    printf("[root] pid=%d\n", getpid());
    spawn_tree(0, 3); // 生成深度 3 的二叉树
    return 0;
}
```

— 回收与僵尸（必备）—
- 子进程退出后，父进程必须 wait()/waitpid() 回收，否则会留下僵尸（defunct）。
- 收割全部已退出子进程（非阻塞）：
```c
#include <sys/wait.h>
void reap_all_children(void) {
    int status;
    while (waitpid(-1, &status, WNOHANG) > 0) {
        // 可解析退出码 WIFEXITED/WEXITSTATUS 等
    }
}
```
- 规模较大或长期运行的父进程：建议安装 SIGCHLD 处理器，在信号中循环 waitpid(-1, …, WNOHANG)。

— I/O 缓冲与退出语义 —
- fork 会复制用户态缓冲。若在 fork 前 printf 但未 fflush，父子都可能再次输出该缓冲，造成“重复打印”错觉。
  - 解决：setvbuf(stdout, NULL, _IONBF, 0) 或在 fork 前 fflush(NULL)；子进程中用 _exit() 而非 exit() 避免重复执行 stdio 清理。
- 子进程结束：
  - 正常：_exit(status)（子进程）/ exit(status)（进程正常路径）
  - 收尾：关闭或继承的文件描述符如不再需要应主动关闭

— 实战验证与辅助工具 —
- 查看父子关系
  - ps -o pid,ppid,stat,cmd -p <pid_list>
  - pstree -ap <root_pid>
- 资源限制与失败排查
  - 进程数限制（ulimit -u / RLIMIT_NPROC）可能导致 fork 失败（返回 -1，errno=EAGAIN）
  - 及时检查 fork 返回值，出现错误要回收已创建子进程或尽快退出

— 练习题（巩固）—
1) 改写“兄弟结构”示例：让父进程限速创建（每次创建间隔 100ms），并记录每个子退出码。
2) 实现“长度为 N 的链”，要求严格自顶向下有序打印 gen 序号（可用管道/等待保证顺序）。
3) 扩展“树形拓扑”：每个子仅在左支继续分叉，右支立即退出，观察进程数与形态变化。
4) 给“兄弟结构”示例添加 SIGCHLD 处理器，做到异步回收且主循环不阻塞。

提示
- 想要“只有父继续创建”：在子分支尽快 break 或 _exit。
- 想要“只有子继续创建”（链式）：在父分支 break，子分支继续循环。
- 任何需要“顺序保证”的打印，使用同步手段（wait/管道/信号）而非 sleep 体验式等待。


## 五、进程退出：exit 与 _exit

- 学习目标
  - 理解进程结束的两条路径：库函数 exit 与系统调用 _exit 的语义差异
  - 掌握 main 中 return 的隐式行为与其他函数 return 的区别
  - 熟悉缓冲区刷新、atexit 处理器、资源清理的触发时机
  - 了解在 fork/exec 场景下为何子进程应优先使用 _exit
  - 正确传递并获取退出状态（父进程 wait/waitpid + WEXITSTATUS）

— 基本概念 —
- 结束当前进程并返回状态值给系统（父进程、shell 可通过 wait/echo $? 获取）
  - exit(int status)：库函数（头文件 stdlib.h；stdio.h 常因使用 I/O 而一并包含）
  - _exit(int status)：系统调用封装（头文件 unistd.h）
- 状态值约定
  - 0 表示成功，非 0 表示错误（约定，不是强制）
  - 父进程用 wait/waitpid 结合 WIFEXITED/WEXITSTATUS 解析

— exit 的行为（库函数）—
- 会做的事
  - 刷新并关闭所有已打开的 stdio 流（stdout/stderr 等），冲洗缓冲区
  - 调用通过 atexit() 注册的处理函数（按后进先出 LIFO 顺序）
  - 执行 C++ 全局/静态对象析构（在 C++ 程序中）
  - 调用底层 _exit 移交内核回收资源（文件描述符、内存等）
- 头文件：stdlib.h（printf 等 I/O 需要 stdio.h）
- 典型影响
  - 即使 printf 没有换行（行缓冲）或处于全缓冲，exit 也会导致数据被刷出并看到输出

— _exit 的行为（系统调用）—
- 不会做的事
  - 不刷新 stdio 缓冲
  - 不调用 atexit 注册函数
  - 不运行 C++ 全局/静态对象析构
- 会做的事
  - 直接将进程状态返回内核，立即终止进程
- 使用场景
  - fork 之后的子进程在 exec 前的错误路径或需要立刻退出时，防止重复冲洗父进程复制来的 stdio 缓冲导致“重复输出”
- 头文件：unistd.h

— main 的 return 与 exit 的关系 —
- 在 main 中 return n 等价于调用 exit(n)：会触发 exit 的全部语义（刷新缓冲、调用 atexit 等）
- 在其他函数中 return 仅返回到调用者，不会结束进程、更不会触发 exit 流程

— C 标准中的 _Exit —
- _Exit(int status)（头文件 stdlib.h）：C99/C11 标准库函数，语义与 POSIX 的 _exit 类似（不做缓冲刷新与 atexit），在纯标准 C 环境中可优先用 _Exit
- 在 glibc 等实现中 _Exit 通常直接调用 _exit

— 缓冲区与重复输出（常见坑）—
- fork 会复制用户态缓冲。若在 fork 前已写入 stdout 但未 fflush，父子进程随后都可能把同一缓冲内容刷出，产生重复打印
- 解决方法
  - 在 fork 前 fflush(NULL) 或将 stdout 设为无缓冲/行缓冲
  - 在子进程中遇错退出时使用 _exit/_Exit，避免再执行 stdio 清理

— 代码示例：exit 刷新 vs _exit 不刷新 —
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    // 示例1：exit 刷新缓冲
    printf("hello with exit");
    // 无换行，但 exit 会刷新
    exit(0);
    // 不会到达
    // 示例2：将上述 exit 改为 _exit(0) 则不会看到输出
}
```

— 代码示例：main return 等价于 exit —
```c
#include <stdio.h>

int main(void) {
    printf("printed before return (main)\n");
    return 0; // 等价于 exit(0)
}
```

— 代码示例：fork/exec 错误路径用 _exit 避免重复输出 —
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    setvbuf(stdout, NULL, _IONBF, 0); // 演示时禁缓冲更直观
    printf("parent before fork\n");

    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }

    if (pid == 0) {               // child
        // 模拟 exec 失败路径
        execlp("nonexistent_cmd", "nonexistent_cmd", (char*)NULL);
        perror("exec");           // 只打印一次
        _exit(127);               // 关键：用 _exit 立即退出，不触发缓冲重复
    } else {                      // parent
        int st;
        waitpid(pid, &st, 0);
        if (WIFEXITED(st)) {
            printf("child exited with %d\n", WEXITSTATUS(st));
        }
    }
    return 0;
}
```

— 父进程获取退出状态 —
```c
#include <sys/wait.h>
// ...
int status;
pid_t r = waitpid(child, &status, 0);
if (r > 0) {
    if (WIFEXITED(status)) {
        int code = WEXITSTATUS(status); // 子进程 exit/_exit/_Exit 的 status
    } else if (WIFSIGNALED(status)) {
        int sig = WTERMSIG(status);     // 被信号终止（如 SIGKILL）
    }
}
```
- 在 shell 中使用 echo $? 可查看最近前台进程的退出码

— atexit 与清理逻辑 —
- 使用 atexit 注册退出时的清理动作（仅在 exit/main return 时调用）
```c
#include <stdlib.h>
#include <stdio.h>

void on_exit1(void){ puts("cleanup #1"); }
void on_exit2(void){ puts("cleanup #2"); }

int main(void) {
    atexit(on_exit1);
    atexit(on_exit2); // 调用顺序：#2 再 #1（LIFO）
    // _exit/_Exit 不会运行这些处理器
    return 0;
}
```

— 易错点与最佳实践 —
- 易错点
  - 误以为“任意函数 return 等于进程退出”：只有 main 的 return 等价 exit
  - fork 后子进程用 exit 导致重复输出：应使用 _exit/_Exit
  - 忘记 wait 子进程导致僵尸：父进程需及时 wait/waitpid 回收
  - 忽视缓冲模式导致“为何没输出/为何重复输出”的困惑
- 最佳实践
  - 需要“立即退出且不做用户态清理”时用 _exit/_Exit
  - 需要“正常清理、刷新、调用 atexit”时用 exit/从 main return
  - fork 前 fflush(NULL) 或设置 stdout 无缓冲/行缓冲
  - 设计良好的退出码语义：0 成功，非 0 依据错误类型编码
  - 在长期运行的父进程中处理 SIGCHLD，非阻塞回收子进程

— 小练习 —
1) 写一个程序：先 printf 不带换行，分别用 exit 与 _exit 结束，观察输出差异
2) 在 fork 后父子都 printf 同样文本但不换行：对比 exit 与 _exit 是否出现重复输出
3) 使用 atexit 注册多个清理函数，验证调用顺序；将退出改为 _exit 验证不会调用
4) 写一段父子程序：父 waitpid 获取并打印子进程退出码；让子进程用不同退出码模拟错误分类



## 六、进程回收：wait 与 waitpid 核心知识

- 学习目标
  - 掌握 wait 与 waitpid 的用法、返回值与错误处理
  - 正确解析子进程退出状态（exit 码、被信号终止等）
  - 使用阻塞/非阻塞回收、多子进程回收与按 PID 精确回收
  - 了解避免/清理僵尸进程的多种策略（SIGCHLD、双重 fork、SA_NOCLDWAIT）

— API 速览 —
- 头文件：#include <sys/wait.h>
- 函数
  - pid_t wait(int* status);
    - 等价于 waitpid(-1, status, 0)：阻塞等待任意子进程结束
  - pid_t waitpid(pid_t pid, int* status, int options);
    - pid > 0：等待特定子进程
    - pid = 0：等待与当前进程同一进程组的任一子进程
    - pid = -1：等待任意子进程（相当于 wait）
    - pid < -1：等待进程组 ID 为 -pid 的任一子进程
    - options 常用：0（阻塞）、WNOHANG（非阻塞）、WUNTRACED/WCONTINUED（可选）
- 返回值
  - 成功：返回回收的子进程 PID
  - 失败：-1，并设置 errno（如 ECHILD、EINTR）

— 解析子进程状态（status 宏）—
- 常用宏（配合 int status）
  - WIFEXITED(status)       子进程正常通过 exit/_exit/return 结束
  - WEXITSTATUS(status)     正常结束的退出码（0..255）
  - WIFSIGNALED(status)     子进程被信号终止
  - WTERMSIG(status)        终止它的信号编号
  - WIFSTOPPED(status)      子进程因信号而停止（作业控制）
  - WSTOPSIG(status)        使其停止的信号
  - WIFCONTINUED(status)    子进程被 SIGCONT 继续执行（需要 WCONTINUED）

— 基础示例：阻塞回收并解析退出码 —
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }
    if (pid == 0) {
        // 子进程：模拟工作并退出码为 2
        sleep(1);
        _exit(2);
    }

    int status;
    pid_t r = wait(&status); // 或 waitpid(-1, &status, 0)
    if (r == -1) { perror("wait"); return 1; }

    if (WIFEXITED(status)) {
        printf("child %d exited, code=%d\n", r, WEXITSTATUS(status));
    } else if (WIFSIGNALED(status)) {
        printf("child %d killed by signal %d\n", r, WTERMSIG(status));
    }
    return 0;
}
```

— 非阻塞回收：WNOHANG 与循环收割 —
```c
#include <errno.h>
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>

void reap_all_children_nonblocking(void) {
    int status;
    for (;;) {
        pid_t r = waitpid(-1, &status, WNOHANG);
        if (r > 0) {
            // 解析 status（略）
            continue;            // 可能有多个子进程已退出，继续收割
        } else if (r == 0) {
            break;               // 当前没有可回收的子进程
        } else {                 // r == -1
            if (errno == EINTR)  // 被信号打断，重试
                continue;
            if (errno == ECHILD) // 没有子进程
                break;
            perror("waitpid");
            break;
        }
    }
}
```

— 多子进程与精确回收 —
- 精确指定某一子进程：waitpid(child_pid, &status, 0)
- 任意子进程（谁先结束先回收）：wait(NULL) 或 waitpid(-1, &status, 0)
- 建议：父进程维护已派生的子 PID 列表，按需选择阻塞/非阻塞回收策略

— 信号驱动回收（推荐长期进程）—
- 利用 SIGCHLD 在子进程退出时触发回收；注意处理 EINTR 与在处理器中循环 waitpid
```c
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>

static void on_sigchld(int sig) {
    int saved = errno;
    int status;
    // 循环收割所有已退出的子进程（非阻塞）
    while (waitpid(-1, &status, WNOHANG) > 0) { /* 可记录日志/统计 */ }
    errno = saved;
}

int main(void) {
    struct sigaction sa = {0};
    sa.sa_handler = on_sigchld;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP; // 不为停止/继续发送 SIGCHLD，自动重启可中断的系统调用
    if (sigaction(SIGCHLD, &sa, NULL) == -1) _exit(1);

    // fork 子进程 ……

    // 主循环
    for (;;) pause();
}
```
- SA_NOCLDWAIT：若设置，内核将自动回收子进程，避免产生僵尸（但也就无法在父进程获取退出码）
- 忽略 SIGCHLD（signal(SIGCHLD, SIG_IGN)）在部分实现上也等效于不产生僵尸（以平台为准）

— 避免僵尸的其他策略 —
- 双重 fork（daemon 化惯用技法）
  - 父进程 fork 出子进程并立即 wait 回收；子进程再 fork 出“孙进程”，随后子进程 _exit()；孙进程被 init/systemd 收养，不会成为僵尸
- 正确选择退出函数
  - 子进程在 fork 后的“错误路径”建议使用 _exit/_Exit，避免刷新缓冲造成重复输出或执行父进程的用户态清理逻辑

— 常见错误与处理 —
- 未回收导致 defunct
  - 现象：ps 显示 “<defunct>”，表示子进程已结束但父未 wait
  - 处理：父进程 wait/waitpid 回收；或使用 SIGCHLD + 非阻塞收割
- 错误解析 status 值
  - 直接打印 status 得到“512”等数值，需用 WIFEXITED/WEXITSTATUS 等宏解析
- wait/Waitpid 被信号中断
  - errno = EINTR：应重试系统调用（阻塞式场景）
- 指定无效 PID
  - waitpid(不存在的 PID, …) 返回 -1，errno=ECHILD；多子进程时可先用 -1 广撒网收割
- 竞态与忙轮询
  - WNOHANG 下应循环收割，避免遗留僵尸；同时避免高频空转，可配合事件/短暂休眠

— 小技巧与排查 —
- Shell 中查看退出码：echo $?
- 可视化父子关系：pstree -ap <ppid>
- 仅看本进程组子进程：waitpid(0, &status, 0)
- 大规模并发派生：注意 RLIMIT_NPROC、PID 枯竭与速率控制；失败时 fork 返回 -1, errno=EAGAIN

— 练习建议 —
1) 启动 N 个子进程，父进程用 wait 非确定顺序回收并打印每个子退出码
2) 改用 waitpid(WNOHANG) + 周期性轮询，验证不会出现僵尸
3) 安装 SIGCHLD 处理器，模拟高频派生与退出，确保无资源泄漏
4) 对比 SA_NOCLDWAIT 与常规回收的区别，理解退出码可用性的权衡

— 参考要点总结 —
- wait ≈ waitpid(-1, …, 0)；waitpid 更灵活（指定 pid、非阻塞）
- 解析 status 必用宏：WIFEXITED/WEXITSTATUS/WIFSIGNALED/WTERMSIG
- 长期服务型父进程：优先用 SIGCHLD + 非阻塞循环回收
- 需要“不留痕”退出的子进程路径：_exit/_Exit
- 不回收就有僵尸；不解析就拿不到可靠退出码





## 七、fork + exec 与 system：exec 函数族与 shell 执行机制核心知识

- 学习目标
  - 理解 shell 通过 fork + exec 执行用户程序的原理
  - 掌握 exec 函数族的成员、参数约定、返回语义与常见用法
  - 正确认知“进程镜像替换”特性及其对后续代码执行的影响
  - 会在代码中选择 execvp/execve/system 等合适方案，并进行可靠的错误处理与回收

— 核心机制：shell 如何执行命令 —
- 流程（简化）
  1) 父进程（shell）调用 fork() 产生子进程
  2) 子进程在自身上下文中调用 exec(...)，将当前进程“替换”为目标程序
  3) 父进程（shell）继续运行，不受子进程替换影响，可继续读命令、管理作业
- 重要结论
  - exec 在成功时不会返回；只有失败才返回 -1 并置 errno
  - 子进程被 exec 成为“新程序”的进程实例，仍是原 shell 的子进程（PPID 不变）

— fork 回顾（极简）—
- pid_t pid = fork();
  - 父进程中返回子进程 PID (>0)
  - 子进程中返回 0
  - 失败返回 -1
- 分支写法常见模板
```c
pid_t pid = fork();
if (pid < 0) { perror("fork"); /* handle */ }
else if (pid == 0) { /* child: exec or _exit on error */ }
else { /* parent: wait/waitpid or继续工作 */ }
```

— exec 函数族（<unistd.h>）—
- 常用变体与差异
  - execl(path, arg0, arg1, ..., (char*)NULL)
  - execlp(file, arg0, arg1, ..., (char*)NULL)         // p: 通过 PATH 搜索可执行文件
  - execv(path, char* const argv[])                    // v: 参数用 argv 数组
  - execvp(file, char* const argv[])                   // vp: PATH 搜索 + argv
  - execle(path, arg0, ..., (char*)NULL, char* const envp[]) // e: 指定环境
  - execve(path, char* const argv[], char* const envp[])     // 最底层系统调用
- 共同要点
  - 成功不返回；失败返回 -1 并设置 errno（如 ENOENT/EACCES/ENOEXEC 等）
  - argv 约定：argv[0] 通常为程序名；参数列表以空指针结尾（l 系列），或数组最后元素为 NULL（v 系列）
  - p 变体从环境变量 PATH 中搜索 file；非 p 变体要求提供绝对/相对路径
  - e/ve 变体允许指定新的环境变量集合 envp（以 NULL 终止的字符串指针数组）
- 示例：execl 与 execlp 运行 ls
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    // 方式一：绝对路径 + 可变参数 + NULL 终止
    // execl("/bin/ls", "ls", "-al", ".", (char*)NULL);

    // 方式二：PATH 搜索 + 可变参数 + NULL 终止
    execlp("ls", "ls", "-al", ".", (char*)NULL);

    // 只有失败才会走到这里
    perror("execl(p) failed");
    return 1;
}
```
- 示例：execv/execvp 使用 argv 数组
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    char* const argv[] = { "ls", "-al", ".", NULL };
    execvp("ls", argv);   // 从 PATH 搜索 “ls”
    perror("execvp failed");
    return 1;
}
```

— “替换”语义与常见注意点 —
- 进程镜像替换
  - exec 成功后，当前进程的代码段/数据段/堆栈等被新程序映射替换，原程序后续代码不再执行
- I/O 缓冲与重复输出
  - fork 会复制用户态缓冲，若在 fork 前已写 stdout 但未 fflush，父子都可能打印同一缓冲
  - 解决：fork 前 fflush(NULL)；子进程错误路径使用 _exit() 立即退出，避免执行 stdio 清理
- 文件描述符继承与 FD_CLOEXEC
  - 默认已打开 FD 会在 exec 后继承；若不希望继承，使用 fcntl(fd, F_SETFD, FD_CLOEXEC) 或在 open 时用 O_CLOEXEC
- 错误处理惯用法（子进程）
```c
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    char* const argv[] = { "ls", "-al", ".", NULL };
    execvp("ls", argv);
    // 失败才会到达
    perror("execvp");
    _exit(127); // 用 _exit，避免重复冲洗缓冲；127 常用于 “命令未找到/执行失败”
}
```

— system 函数（<stdlib.h>）—
- 用法与语义
  - int system(const char* command);
  - 实际上由库内部 fork 出子进程并通过 “/bin/sh -c command” 执行命令；调用者阻塞等待完成
  - 返回值为子进程的 wait status（需用 WIFEXITED/WEXITSTATUS 宏解析）
- 特点对比
  - 简单：单字符串命令（可包含管道/重定向，由 shell 解析）
  - 同步：等待命令结束后才返回，便于顺序逻辑
  - 安全：传入不受信任输入存在注入风险（谨慎使用）
- 示例：解析退出码
```c
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>

int main(void) {
    int st = system("ls -al .");
    if (st == -1) { perror("system"); return 1; }
    if (WIFEXITED(st)) {
        printf("exit code = %d\n", WEXITSTATUS(st));
    } else if (WIFSIGNALED(st)) {
        printf("killed by signal %d\n", WTERMSIG(st));
    }
    return 0;
}
```

— 选择建议：exec vs system vs 自己 fork+exec —
- exec(家族)
  - 适用：已在子进程中、明确程序与参数、无需 shell 解析；性能与可控性更好
- system
  - 适用：快速执行一条 shell 命令、需要管道/通配符/重定向等 shell 语法；注意安全与同步阻塞
- 自己 fork + execvp + waitpid
  - 适用：需要异步/并发、可控的错误处理、精细的 I/O/FD 继承策略、非阻塞回收（WNOHANG / SIGCHLD）

— 常见错误与排查 —
- 误区：以为 exec 成功后会返回 0
  - 更正：exec 成功不返回；只有失败才返回 -1 并设置 errno
- PATH 导致的 “command not found”
  - 使用 execlp/execvp 依赖 PATH；用绝对路径（/bin/ls）可规避
- 参数终止与 argv[0]
  - l 系列需以 (char*)NULL 结束参数；v 系列的数组需以 NULL 终止
  - argv[0] 通常为程序名，某些程序依赖其值决定行为
- 僵尸进程
  - 父进程应 wait/waitpid 回收；或使用 SIGCHLD 处理器/双重 fork/SA_NOCLDWAIT

— 进阶提示 —
- 需要可移植的 spawn 行为可考虑 posix_spawn()/posix_spawnp()（常由内核或 C 库优化，综合 fork+exec）
- 需要定制环境：使用 execle/execve 传入 envp；或先 setenv/unsetenv 再 exec
- 需要隔离文件描述符泄漏：系统性使用 O_CLOEXEC/FD_CLOEXEC

— 练习建议 —
1) 实现一个极简“迷你 shell”：读取一行命令→fork→子进程 execvp(...)→父进程 waitpid
2) 对比 execlp 与 execvp：将参数从变长参数改为 argv 数组
3) 在子进程错误路径使用 _exit(127) 与在父进程解析退出码，区别对待命令未找到/被信号终止
4) 为某些文件描述符设置 FD_CLOEXEC，验证 exec 后句柄是否被关闭

```c
// 迷你 shell 轮廓（仅演示要点，不含完整解析与健壮性）
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void){
    char line[1024];
    for(;;){
        fputs("mini$ ", stdout);
        if(!fgets(line, sizeof line, stdin)) break;
        if(line[0]=='\n') continue;
        if(!strncmp(line,"exit",4)) break;

        // 粗略拆分为 argv（仅空格分割，示例用）
        char* argv[64] = {0};
        int n=0;
        for(char* tok=strtok(line," \t\r\n"); tok && n<63; tok=strtok(NULL," \t\r\n")) argv[n++]=tok;
        if(n==0) continue;

        pid_t pid=fork();
        if(pid==0){
            execvp(argv[0], argv);
            perror("execvp");
            _exit(127);
        } else if(pid>0){
            int st; waitpid(pid,&st,0);
        } else {
            perror("fork");
        }
    }
    return 0;
}
```


## 八、exec 函数族与进程替换：要点、易错与实践范式

- 学习目标
  - 彻底理解 exec 函数族的参数约定（argv[0]、NULL 终止、PATH 搜索、env 传递）
  - 掌握“进程镜像替换”语义：成功后不返回、PID 不变、父进程无影响
  - 正确向新程序传参与环境变量，避免“参数错位/丢失”
  - 会用 fork+exec 避免替换当前进程，并进行健壮的错误处理与回收
  - 理解 exec 对文件描述符、信号处理等进程属性的影响

— exec 函数族总览（<unistd.h>）—
- 常用接口
  - execl(path, arg0, arg1, …, (char*)NULL)
  - execlp(file, arg0, arg1, …, (char*)NULL)            // p: 通过 PATH 搜索
  - execv(path, char* const argv[])                     // v: 用 argv 数组
  - execvp(file, char* const argv[])                    // vp: PATH 搜索 + argv[]
  - execle(path, arg0, …, (char*)NULL, char* const envp[]) // e: 指定环境
  - execve(path, char* const argv[], char* const envp[])   // 最底层系统调用
- 共同语义
  - 成功时不返回；只有失败才返回 -1 并设置 errno（ENOENT/EACCES/ENOEXEC…）
  - 参数必须以空指针终止：
    - l 系列：最后一个可变参数必须是 (char*)NULL
    - v 系列：argv[] 最后一项必须为 NULL
  - argv[0] 必须提供，通常为“程序名”；很多程序依赖 argv[0]（用来决定行为/显示帮助等）
  - p 变体使用 PATH 搜索可执行文件；非 p 变体需提供可执行文件路径（绝对/相对）

— 进程镜像替换（核心语义）—
- exec 成功后，当前进程的代码段/数据段/堆/栈被新程序映射替换；原程序后续代码不再执行
- PID 不变（仍是同一个进程实例），PPID 也不变（在 shell 视角仍是它的子进程）
- 父进程完全不受影响（除非父子间另有同步/通信逻辑）

— 参数传递与“第零个参数”—
- argv[0] 要点
  - 必须提供；通常写被执行程序的名字（如 "ls"）
  - 某些程序用 argv[0] 决定自身行为（例如 busybox、某些多态命令）
  - 缺失 argv[0] 会导致后续参数“左移”，使选项/位置参数错位，表现为“参数丢了/行为不一致”
- “参数没被使用”的澄清
  - exec 会把 argv[] 传递给新程序；是否“使用”取决于新程序如何解析 argv
  - 若目标程序未读取 argv（如仅打印常量字符串），你会感觉“参数没用上”，但这不是 exec 的问题

— 示例 1：execlp 运行 ls（必须以 NULL 终止，含 argv[0]）—
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    execlp("ls", "ls", "-al", ".", (char*)NULL);
    perror("execlp failed");     // 只有失败才会执行到这里
    return 1;
}
```

— 示例 2：execvp 传递 argv 数组—
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    char* const argv[] = { "ls", "-al", ".", NULL };  // argv[0] = "ls"
    execvp("ls", argv);                               // PATH 搜索
    perror("execvp failed");
    return 1;
}
```

— 示例 3：目标程序接收参数（验证 argv 传递正常）—
```c
// target.c
#include <stdio.h>
int main(int argc, char* argv[]) {
    printf("argc=%d\n", argc);
    for (int i = 0; i < argc; ++i) printf("argv[%d]=%s\n", i, argv[i]);
    return 0;
}
```
```c
// launcher.c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    char* const argv[] = { "target", "AAA", "BBB", NULL }; // argv[0]="target"
    execv("./target", argv);
    perror("execv failed");
    return 1;
}
```
- 运行可见 target 正常收到 "AAA"/"BBB"；若省略 argv[0]，参数位置将错乱

— 避免替换当前进程：fork + exec 范式（推荐）—
```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

int main(void) {
    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }
    if (pid == 0) {                   // 子进程
        char* const argv[] = { "ls", "-al", ".", NULL };
        execvp("ls", argv);           // 成功不返回
        perror("execvp");             // 失败才到达
        _exit(127);                   // 子进程用 _exit，避免重复冲刷缓冲
    }
    // 父进程继续执行，不被替换
    int st; waitpid(pid, &st, 0);     // 回收子进程，避免僵尸
    return 0;
}
```

— 环境变量与 exec（e / ve 变体）—
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    char* const argv[] = { "printenv", "FOO", NULL };
    char* const envp[] = { "FOO=BAR", "PATH=/usr/bin:/bin", NULL };
    execve("/usr/bin/printenv", argv, envp);  // 用自定义环境执行
    perror("execve failed");
    return 1;
}
```

— I/O、文件描述符与信号：exec 的进阶影响—
- 文件描述符
  - 已打开的文件描述符在 exec 后默认保持打开
  - 需防泄漏：对不希望继承的 FD 设置 FD_CLOEXEC（fcntl）或 open 时使用 O_CLOEXEC
- 标准 I/O 缓冲
  - fork 前已写入但未 fflush 的用户态缓冲可能在父/子各自被刷出（重复输出）
  - 习惯：fork 前 fflush(NULL)；子进程错误路径用 _exit()
- 信号处理
  - 被“捕获”的信号处置在 exec 后会重置为默认（忽略的信号保持忽略）
  - 信号屏蔽（mask）一般保留；挂起的信号不会在新镜像里“继承触发”
- 工作目录、资源限制、umask 等属性通常保留至新镜像

— system 与 exec 的取舍—
- system(command)
  - 内部等价于 fork + “/bin/sh -c command” + wait；调用者阻塞等待
  - 支持 shell 语法（管道、通配符、重定向），简单好用但有注入风险
- exec 家族
  - 精准、可控、可异步（配合 fork/waitpid），不依赖 shell 解析；安全性更高

— 常见错误与排查—
- 误以为“exec 成功返回 0”：更正：成功不返回；失败 -1 并置 errno
- 忘写 NULL 终止：导致崩溃/未定义行为
- 省略 argv[0]：参数错位，程序表现异常
- 依赖 PATH 但环境未设置：换用绝对路径或修正 PATH
- 忘记回收子进程：产生 <defunct> 僵尸；父进程应 wait/waitpid 或用 SIGCHLD 处理器
- 错误路径使用 exit 而非 _exit：可能导致缓冲重复输出/父进程清理逻辑被错误执行

— 常见 errno（失败返回 -1 时）—
- ENOENT：文件不存在或 PATH 中未找到
- EACCES：无执行权限或目录不可进入
- ENOEXEC：不是可执行文件且非脚本（缺少 shebang 等）
- ETXTBSY：文本文件忙（极少见）
- E2BIG：参数/环境太大

— 小练习—
1) 省略 argv[0] 重跑 ls，对比输出差异，理解“参数左移”的影响
2) 用 execve 传入最小化环境（仅 PATH），验证缺失变量对目标程序的影响
3) 给若干 FD 设置 FD_CLOEXEC，验证 exec 后是否关闭
4) 写一个迷你启动器：父进程并行启动 N 个子进程执行不同命令，父进程非阻塞回收（WNOHANG + SIGCHLD）

提示
- 想“运行其它程序但不替换自己”：用 fork 在子进程里 exec
- 想“替换当前进程镜像”：直接 exec（成功后不再返回）
- argv[0] 必须给，参数列表必须以 NULL 终止；p 变体依赖 PATH
- 子进程错误路径务必 _exit(…) 收尾，父进程要记得 wait/waitpid




## 九、守护进程（Daemon）核心知识

- 学习目标
  - 理解守护进程的定义、特点与典型场景
  - 掌握进程组、会话、控制终端（TTY）等相关概念
  - 熟悉标准“守护化（daemonize）”步骤与理由（fork/setsid/chdir/umask/关闭FD）
  - 会编写健壮的守护化代码（双重 fork、重定向到 /dev/null、PID 文件、信号处理）
  - 知道 nohup、disown 与系统服务（systemd）方式的差异与取舍

— 守护进程概述 —
- 定义：独立于控制终端（controlling terminal）在后台长期运行的服务进程。英文 daemon（常写作 daemon/dæmon）。
- 核心特点
  - 后台运行，独立于任何终端（无控制终端，终端关闭/退出不影响其存活）
  - 生命周期长，通常周期性执行任务或常驻提供服务
  - 不能用 fg/bg 在前后台切换（因其与终端无关）
- 常见例子：sshd、cron、nginx/httpd、mysqld、systemd 等

— 相关概念（进程组/会话/控制终端）—
- 进程组（Process Group）
  - 一组相关进程的集合，用于作业控制；每组有一个组长（PGID = 组长 PID）
- 会话（Session）
  - 一个或多个进程组的集合；通常一个登录终端对应一个会话；会话可拥有一个控制终端
- 控制终端（Controlling TTY）
  - 会话与用户交互的终端设备（如 pts/0）；向前台进程组发送作业控制信号（如 Ctrl+C→SIGINT）
- 关键关系
  - 每个进程属于一个进程组；每个进程组属于一个会话
  - 会话首领（Session Leader）可能与终端建立控制关系；守护进程应避免拥有控制终端

— 为什么要“守护化” —
- 脱离终端：避免因终端关闭/信号造成退出（SIGHUP 等）
- 稳定运行：不受用户登录/会话变化影响
- 资源管理：规范工作目录、权限掩码、文件描述符，降低意外副作用

— 标准守护化步骤（经典范式）—
1) 第一次 fork，父进程退出
   - 目的：让子进程不再是原会话与进程组的组长，从而为 setsid 创造条件
2) setsid() 创建新会话，成为会话首领且脱离原控制终端
   - 子进程成为新会话的会话首领和新进程组的组长
3) 可选第二次 fork（双重 fork）
   - 目的：避免会话首领未来再次打开 TTY 而重新获得控制终端
   - 第二次 fork 后的孙进程不再是会话首领，无法获得控制终端
4) 更改工作目录（通常 chdir("/")）
   - 避免守护进程持有可卸载/删除的工作目录（阻碍卸载）
5) 重置文件权限掩码（umask）
   - 常设为 0 或更严（如 027），确保后续创建文件权限可控且不受继承影响
6) 关闭继承的文件描述符
   - 关闭 0/1/2（标准输入/输出/错误），以及其他打开的 FD，避免意外占用/泄漏
   - 通常将 0/1/2 重定向到 /dev/null（或到日志文件）

— 最小可用守护化示例（教学用，省略若干健壮性）—
```c
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

static void daemonize_min(void) {
    pid_t pid = fork();
    if (pid < 0) _exit(1);
    if (pid > 0) _exit(0);             // 退出父进程

    if (setsid() < 0) _exit(1);        // 脱离控制终端，成为新会话

    pid = fork();                      // 可选：第二次 fork
    if (pid < 0) _exit(1);
    if (pid > 0) _exit(0);             // 退出中间进程

    umask(0);                          // 重置权限掩码
    chdir("/");                        // 切换到根目录

    // 关闭并重定向标准 I/O
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    int fd = open("/dev/null", O_RDWR);
    if (fd >= 0) {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
        if (fd > 2) close(fd);
    }
}

int main(void) {
    daemonize_min();
    // 守护进程主体逻辑（周期性任务/服务循环）
    for (;;){
        // ...
        sleep(60);
    }
    return 0;
}
```

— 生产可用守护化要点（健壮版建议）—
- 双重 fork：严格避免重新获得控制终端
- 关闭全部 FD：枚举上限（sysconf(_SC_OPEN_MAX) 或 getrlimit(RLIMIT_NOFILE)）循环关闭
- 日志：使用 syslog(3) 或专用日志（注意权限与轮转）
- PID 文件：/run/xxx.pid 或 /var/run/xxx.pid；加文件锁（flock）防多实例
- 信号处理
  - 忽略 SIGHUP，处理 SIGTERM/SIGINT（优雅退出），处理 SIGCHLD（回收子进程）
  - 可设 sigaction，使用 SA_RESTART 避免系统调用被中断
- 权限降级
  - 若以 root 启动，尽早 setgid()/setuid() 切换到受限用户，或使用 Linux Capabilities
- 资源限制
  - 配置 RLIMIT_*（如 NOFILE、CORE、AS）与 umask，确保安全与可控
- 环境清理
  - 清理继承的环境变量（PATH、LD_* 等），或构造最小化安全环境

— 双重 fork 的必要性（原理补充）—
- setsid 后的进程是会话首领；会话首领若打开终端设备，可能被该终端设为控制终端
- 再 fork 一次使最终进程不再是会话首领，消除未来意外获取控制终端的可能

— 校验与排查（如何确认“已守护化”）—
- 观察属性
  - ps -o pid,ppid,pgid,sid,tty,stat,cmd -p <PID>：TTY 通常为 “?”
  - /proc/<PID>/fd/、/proc/<PID>/{cwd,environ,cmdline,stat}：查看 FD 重定向、工作目录等
  - pstree -ap <PID>：查看父子关系（是否被 PID 1/systemd 收养）
- 常见症状与原因
  - 仍受 Ctrl+C 影响：未脱离会话/控制终端（漏做 setsid/双重 fork）
  - 终端关闭进程退出：仍依赖终端或未忽略 SIGHUP
  - 占用目录无法卸载：未 chdir("/")，进程 hold 住路径
  - 输出“丢失/错位”：未重定向 0/1/2；写 stdout/stderr 无人接收

— nohup、&、disown 与守护化的区别 —
- cmd &：后台作业，仍与当前 shell 会话相关，关闭终端可能发 SIGHUP 导致退出
- nohup cmd &：忽略 SIGHUP，stdout/stderr 重定向到 nohup.out（若未显式重定向）
- disown：将作业从 shell 作业表移除，避免 SIGHUP
- 这些方法“近似后台”，但未完成标准守护化步骤（进程可能仍有会话属性与 FD 遗留）；更适合临时需求

— 与 systemd 配合（现代 Linux 建议）—
- 若运行在采用 systemd 的发行版，推荐编写前台服务程序（不自守护化），交给 systemd 管理
  - systemd 单元示例（Type=simple，程序前台运行）：
```ini
[Unit]
Description=My Service

[Service]
Type=simple
ExecStart=/usr/local/bin/myservice
Restart=on-failure
User=svcuser
Group=svcuser
WorkingDirectory=/var/lib/myservice
# Standard输出/错误可由 journald 接管
# StandardOutput=journal
# StandardError=journal
# Environment=FOO=bar

[Install]
WantedBy=multi-user.target
```
- 若程序内部自行 daemonize（forking），可用 Type=forking；但一般不再推荐

— 参考 API 速记 —
- 组/会话/TTY
  - getpid()/getppid()，getpgrp()/getpgid(pid)，setpgid()
  - getsid(pid)，setsid()
- 文件与权限
  - umask(mode_t)，chdir(path)
  - sysconf(_SC_OPEN_MAX)，getrlimit/setrlimit(RLIMIT_NOFILE,…)
  - open/close/dup2，O_CLOEXEC/FD_CLOEXEC
- 信号
  - sigaction，sigemptyset/sigaddset，kill
  - SIGHUP/SIGTERM/SIGINT/SIGCHLD

— 实用“守护化”函数（较完整示例，含 PID 文件与信号框架）—
```c
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/file.h>
#include <sys/resource.h>
#include <signal.h>
#include <stdio.h>
#include <errno.h>

static int write_pidfile(const char* path, int* out_fd) {
    int fd = open(path, O_RDWR|O_CREAT, 0644);
    if (fd < 0) return -1;
    if (flock(fd, LOCK_EX | LOCK_NB) < 0) { close(fd); errno = EEXIST; return -1; }
    if (ftruncate(fd, 0) == 0) {
        char buf[64]; int n = snprintf(buf, sizeof buf, "%ld\n", (long)getpid());
        (void)write(fd, buf, n);
    }
    if (out_fd) *out_fd = fd; // 保持锁存活
    return 0;
}

static int close_all_fds(void) {
    struct rlimit rl;
    if (getrlimit(RLIMIT_NOFILE, &rl) != 0) rl.rlim_max = 1024;
    for (int fd = 0; fd < (int)rl.rlim_max; ++fd) close(fd);
    return 0;
}

static void daemonize_full(const char* pidfile) {
    pid_t pid = fork();
    if (pid < 0) _exit(1);
    if (pid > 0) _exit(0);

    if (setsid() < 0) _exit(1);

    signal(SIGHUP, SIG_IGN); // 忽略挂断信号
    pid = fork();
    if (pid < 0) _exit(1);
    if (pid > 0) _exit(0);

    umask(027);
    chdir("/");

    close_all_fds();
    int nullfd = open("/dev/null", O_RDWR);
    if (nullfd >= 0) {
        dup2(nullfd, STDIN_FILENO);
        dup2(nullfd, STDOUT_FILENO);
        dup2(nullfd, STDERR_FILENO);
        if (nullfd > 2) close(nullfd);
    }

    if (pidfile) {
        int lockfd;
        if (write_pidfile(pidfile, &lockfd) != 0) _exit(1);
        // 保持 lockfd 打开直至进程退出
    }

    // 安装必要的信号处理器（示例）
    struct sigaction sa = {0};
    sa.sa_handler = SIG_IGN; sigaction(SIGPIPE, &sa, NULL); // 忽略 SIGPIPE
    // 其他 SIGTERM/SIGINT/SIGCHLD 自行按需安装
}
```

— 实战建议 —
- 如果目标环境由 systemd 管理，优先写“前台常驻”的服务，交给 systemd 负责重启、日志与资源
- 手工守护化时，务必包含：双重 fork、setsid、重定向 0/1/2、关闭多余 FD、umask、chdir
- 生产环境加上：PID 文件+锁、信号处理与优雅退出、权限降级、日志策略、资源限制
- 用 ps/pstree/proc 明确验证“无 TTY”“被 PID1/systemd 收养”“FD 重定向到 /dev/null”

提示
- nohup/disown/& 仅用于临时后台跑任务，不等同完整守护化
- 忘记 setsid/第二次 fork 常导致“仍受终端影响”
- 忘记关闭/重定向 FD 会造成终端被占用、输出丢失或泄漏
- umask 与权限建议明确设置，避免因继承导致的“过宽/过窄”权限


## 十、守护进程构建
- 通过代码完成“标准守护化”：fork → setsid →（可选二次 fork）→ umask → chdir → 关闭/重定向 FD
- 演示读取与验证 ID：PID/PGID/SID
- 关闭标准文件描述符后，将运行状态写入日志文件进行监控
- 提供可启动/可停止/可观察的完整示例

关键要点
- ID 获取
  - PID：getpid()
  - PPID：getppid()
  - 进程组 PGID：getpgid(0) 或 getpgrp()
  - 会话 ID：getsid(0)
- 守护化步骤
  1) fork 一次让父进程退出（子进程脱离原控制关系的前置步骤）
  2) 子进程 setsid() 成为新会话首领、进程组长并脱离控制终端
  3) 可选二次 fork，避免进程再次获得控制终端
  4) umask(027 或 0)，确立文件默认权限策略
  5) chdir("/")，避免持有可删除的工作目录
  6) 关闭全部继承的 FD，并将 0/1/2 重定向到 /dev/null
- 日志输出
  - 关闭标准输出/错误后，使用单独打开的日志文件（O_APPEND）记录状态
  - 典型路径：/tmp/mydaemon.log（非 root 环境更便于演示）
- 管理建议
  - 写 PID 文件（/tmp/mydaemon.pid），便于脚本化 stop/start
  - 信号处理：SIGTERM/SIGINT 优雅退出；SIGHUP 可用于重新打开日志；忽略 SIGPIPE

构建与运行
- 构建
  - gcc -O2 -Wall -Wextra -o mydaemon mydaemon.c
- 启动（默认使用 /tmp 路径）
  - ./mydaemon --log /tmp/mydaemon.log --pidfile /tmp/mydaemon.pid
- 观察
  - tail -f /tmp/mydaemon.log
  - ps -o pid,ppid,pgid,sid,tty,stat,cmd -p "$(cat /tmp/mydaemon.pid)"
    - 守护化后 TTY 应为 “?”；PPID 多为 1（或 systemd 的 PID）
- 停止
  - kill -TERM "$(cat /tmp/mydaemon.pid)"
  - 或删除遗留的 PID 文件

注意
- 非 root 环境下请使用 /tmp 等可写目录作为日志与 PID 存放路径
- 如果需要将 stdout/stderr 也写入日志，可 dup2(log_fd, STDOUT_FILENO/STDERR_FILENO)（本示例采用独立日志 FD）

## 十一、gdb调试多进程
目标
- 用 GDB 调试含 fork/exec 的多进程程序
- 跟踪父/子进程或同时调试二者，并在进程间切换
- 常用命令与典型工作流脚本化

准备
- 编译时加调试信息，尽量关闭优化，避免步进混乱
  - gcc -g -O0 -Wall -o fork_demo fork_demo.c
- 进入 GDB（TUI 可选：gdb -tui ./fork_demo）
- 建议用 start 从 main 断点处启动（单步预热），而不是直接 run
  - start          # 自动在 main 处临时断点并运行到此

核心命令（准确拼写）
- 跟踪 fork 后跟随谁
  - set follow-fork-mode child     # 跟随子进程
  - set follow-fork-mode parent    # 跟随父进程（默认多数发行版如此）
  - show follow-fork-mode
- 同时调试父子（多进程）
  - set detach-on-fork off         # 关闭“在 fork 时从非跟随进程分离”
  - show detach-on-fork            # 默认通常为 on
  - info inferiors                 # 列出受控的所有进程（inferiors）
  - inferior N                     # 切换到编号为 N 的进程
  - detach inferior N              # 从编号为 N 的进程分离（让其自行运行）
  - kill inferiors                 # 终止当前或全部受控进程（谨慎）
- 捕获 fork/exec 事件（更精细控制）
  - catch fork                     # 在 fork 发生处中止
  - catch vfork
  - catch exec                     # 在 exec 前后中止
  - set follow-exec-mode same|new  # exec 后替换当前进程(same)或新建一个进程(new)
- 基本步进与断点
  - break file.c:LINE | break func
  - tbreak main                    # 一次性断点
  - next / step / continue / finish
- 其它有用项
  - set pagination off
  - set print pretty on
  - help set follow-fork-mode      # GDB 内置帮助
  - Tab 补全：在 set fo<Tab> 等可自动补全命令与参数

典型工作流 A：只调试子进程
1) gdb ./fork_demo
2) set follow-fork-mode child
3) start
4) 正常设断点、next/step 调试（此时 GDB 在 fork 后会跟随子进程）

典型工作流 B：同时调父/子并切换
1) gdb ./fork_demo
2) set follow-fork-mode child
3) set detach-on-fork off         # 保持父子都在调试器控制下
4) start
5) info inferiors                 # 查看两个进程的编号
6) inferior 1 / inferior 2       # 在父/子之间切换
7) 在各自上下文中设置断点与步进

进阶选项（按需）
- 多进程同时运行（继续时让所有进程一起跑）
  - set schedule-multiple on      # continue 时恢复所有 inferior 的线程（默认 off，仅当前进程）
- 与 exec 结合
  - catch exec
  - set follow-exec-mode new      # exec 后保留旧进程上下文并新增一个（便于前后对比）
- 在线程与进程间查看
  - info threads                  # 当前进程的线程
  - thread apply all bt           # 所有线程回溯（仅当前 inferior）
  - 切换进程用 inferior N，再查看线程

常见坑
- 忘记 -g 或高优化（-O2/-O3）导致步进跳跃、变量不可见
- 错拼命令（注意横杠）：follow-fork-mode、detach-on-fork、follow-exec-mode
- 跟随模式需在 fork 发生之前设置；fork 之后修改只影响后续 fork
- 同时调多进程时默认仅当前进程会继续运行（需 set schedule-multiple on 才会全体继续）
- 断点位置在两个进程共享代码中会被两边命中；可在进程间切换后单独 enable/disable 断点

最小示例
```c
// fork_demo.c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(void){
    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }
    if (pid == 0) {
        printf("Child: pid=%d, ppid=%d\n", getpid(), getppid());
        sleep(2);
    } else {
        printf("Parent: pid=%d, child=%d\n", getpid(), pid);
        sleep(2);
    }
    return 0;
}
```

示例会话片段
```
(gdb) set follow-fork-mode child
(gdb) set detach-on-fork off
(gdb) start
Temporary breakpoint 1 at 0x....: file fork_demo.c, line 6.
(gdb) continue
[New inferior 2 (process 12346)]       # 子进程出现
[Switching to inferior 2 ...]          # 自动切到子进程
(gdb) info inferiors
  Num  Description       Executable
* 2    process 12346     ./fork_demo
  1    process 12345     ./fork_demo
(gdb) inferior 1                         # 切回父进程
(gdb) break fork_demo.c:12               # 父进程断点
(gdb) inferior 2                         # 再切回子进程
(gdb) next
```

故障排查
- “fork 后仍在父进程”：确认 set follow-fork-mode child 是否在 fork 之前设置
- “只有一个进程在跑”：set detach-on-fork off +（可选）set schedule-multiple on
- “exec 后代码丢了”：用 catch exec + set follow-exec-mode new 观察新旧镜像
- “命令报错/拼写不对”：在关键单词后按 Tab 查看可用选项与合法值

小贴士
- gdb --args ./prog arg1 arg2        # 带参数启动
- layout src / layout split           # TUI 布局查看源码与寄存器
- 需仅调子进程也可先让父进程退出（或在父进程处 detach），但不如 follow-fork 更直接