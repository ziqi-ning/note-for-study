# 进程间通信


## 一、无名管道（pipe）：概念、API、用法与细节

- 摘要
  - 进程间通信（IPC）常见方式：无名管道、命名管道（FIFO）、信号、共享内存、套接字；System V IPC（消息队列、信号量、共享内存）等。
  - 无名管道是最基础的 IPC 之一，适用于“具有亲缘关系”的进程（典型为 fork 前后）进行单工通信。
  - 通过 pipe 创建一对文件描述符 fd[2]（fd[0] 读端、fd[1] 写端），在内核缓冲区内传递数据。

- 分段总结
  - 进程间通讯介绍
    - IPC 方式多样；生产环境中套接字使用最广（跨主机/同主机均可），但本课程首先掌握管道等本地 IPC。
  - 无名管道原理
    - 内核开辟“管道缓冲区”，两个文件描述符分别对应读/写；本质是内核管理的环形缓冲，用户不可寻址。
  - 无名管道创建
    - int pipe(int fd[2])，头文件 unistd.h；成功返回 0，失败 -1；fd[0] 读，fd[1] 写。
  - 无名管道示例
    - 父进程/子进程通过管道进行单向数据传递；需要正确关闭未使用的一端，避免阻塞和资源泄露。

- 重点
  - IPC 方式与适用场景
  - 无名管道的“亲缘关系”限制与“单工通信”
  - pipe 的用法与读写端语义
  - 必须在各自进程中关闭“不使用的端”，否则会影响 EOF 与阻塞行为

- 核心概念与特性
  - 亲缘关系
    - 无名管道通常用于 fork 前创建，fork 后父子进程继承同一对 fd；无亲缘关系的进程无法直接拿到这对 fd。
  - 单工通信
    - 一条无名管道只支持“单向流动”（要双向通信需两条管道）。
  - fd 继承
    - fork 后父子都持有 fd[0]/fd[1]；各自应立即关闭“不用的那端”，避免：
      - 读端看不到 EOF（仍有进程持有写端）
      - 写端写入对端不读时的阻塞或 SIGPIPE 异常不符合预期
  - 阻塞行为（默认阻塞）
    - 当管道为空且读端 read → 阻塞
    - 当管道满且写端 write → 阻塞
    - 所有写端都关闭后，读端 read 返回 0（EOF）
    - 所有读端都关闭后，写端 write 触发 SIGPIPE（默认终止）且返回 -1，errno=EPIPE

- API 速览
  - int pipe(int fd[2])
    - 头文件：#include <unistd.h>
    - 成功：fd[0] 为读端，fd[1] 为写端；返回 0
    - 失败：返回 -1，并设置 errno
  - Linux 扩展：int pipe2(int fd[2], int flags)
    - flags 可用 O_CLOEXEC（防泄漏到 exec 后进程）、O_NONBLOCK（非阻塞）等
    - 头文件：#include <fcntl.h>, <unistd.h>

- 示例 1：子进程写、父进程读（单向通信，正确关闭未用端）
  ```c
  // file: pipe_child_writes_parent_reads.c
  #define _POSIX_C_SOURCE 200809L
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>
  #include <sys/types.h>
  #include <errno.h>

  int main(void) {
      int fd[2];
      if (pipe(fd) == -1) {
          perror("pipe");
          return 1;
      }

      pid_t pid = fork();
      if (pid < 0) {
          perror("fork");
          return 1;
      } else if (pid == 0) {
          // 子进程：写
          close(fd[0]); // 关闭读端
          const char* msg = "hello from child\n";
          for (int i = 0; i < 5; ++i) {
              ssize_t n = write(fd[1], msg, strlen(msg));
              if (n < 0) { perror("write"); break; }
              sleep(1);
          }
          close(fd[1]); // 关闭写端，父进程可在读端收到 EOF
          _exit(0);
      } else {
          // 父进程：读
          close(fd[1]); // 关闭写端
          char buf[128];
          for (;;) {
              ssize_t n = read(fd[0], buf, sizeof(buf)-1);
              if (n < 0) {
                  if (errno == EINTR) continue;
                  perror("read");
                  break;
              }
              if (n == 0) { // EOF：所有写端关闭
                  printf("parent: EOF\n");
                  break;
              }
              buf[n] = '\0';
              fputs(buf, stdout);
          }
          close(fd[0]);
          // 可 waitpid(pid, NULL, 0) 等子进程结束
      }
      return 0;
  }
  ```

- 示例 2：双向通信（两条无名管道：父→子、子→父）
  ```c
  // file: pipe_duplex_parent_child.c
  #define _POSIX_C_SOURCE 200809L
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>
  #include <sys/types.h>
  #include <errno.h>

  int main(void) {
      int p2c[2]; // parent -> child
      int c2p[2]; // child  -> parent
      if (pipe(p2c) == -1 || pipe(c2p) == -1) { perror("pipe"); return 1; }

      pid_t pid = fork();
      if (pid < 0) { perror("fork"); return 1; }
      if (pid == 0) {
          // 子进程：读 p2c[0]、写 c2p[1]
          close(p2c[1]); close(c2p[0]);
          char buf[128];
          ssize_t n = read(p2c[0], buf, sizeof(buf)-1);
          if (n > 0) {
              buf[n] = '\0';
              fprintf(stdout, "child got: %s", buf);
              const char* reply = "ack from child\n";
              if (write(c2p[1], reply, strlen(reply)) < 0) perror("write");
          }
          close(p2c[0]); close(c2p[1]);
          _exit(0);
      } else {
          // 父进程：写 p2c[1]、读 c2p[0]
          close(p2c[0]); close(c2p[1]);
          const char* msg = "ping from parent\n";
          if (write(p2c[1], msg, strlen(msg)) < 0) perror("write");
          close(p2c[1]); // 重要：写完及时关闭，便于子进程读到 EOF

          char buf[128];
          ssize_t n = read(c2p[0], buf, sizeof(buf)-1);
          if (n > 0) { buf[n] = '\0'; fprintf(stdout, "parent got: %s", buf); }
          else if (n == 0) fprintf(stdout, "parent: EOF on c2p\n");
          else perror("read");

          close(c2p[0]);
          // waitpid(pid, NULL, 0);
      }
      return 0;
  }
  ```

- 行为与实现细节（常考/易错）
  - 关闭未使用端
    - 父写子读：父进程关闭读端 fd[0]，子进程关闭写端 fd[1]；反之亦然。
    - 不关闭会导致：读端永远收不到 EOF；进程持有多余端导致资源泄漏、阻塞异常。
  - 原子性与 PIPE_BUF
    - 对同一管道的并发写：单次 write() 长度 ≤ PIPE_BUF（POSIX 至少 512 字节，Linux 通常 4096）时具有原子性；超出可能被拆分、交叉。
  - 部分读/写与 EINTR
    - read/write 可能返回部分字节；需循环处理。
    - 被信号打断返回 -1 且 errno=EINTR，应重试。
  - SIGPIPE 与 EPIPE
    - 所有读端关闭后，写端 write → 触发 SIGPIPE（默认终止）且返回 -1/EPIPE；可忽略 SIGPIPE 或用 MSG_NOSIGNAL（针对套接字）等手段避免崩溃（管道可用 signal(SIGPIPE, SIG_IGN) 或检查对端是否仍打开）。
  - 非阻塞与事件复用
    - 可用 pipe2(fd, O_NONBLOCK|O_CLOEXEC) 或 fcntl 设置 O_NONBLOCK。
    - 配合 select/poll/epoll 监控可读/可写事件；空→可读；满→不可写。
  - 与 exec 的交互
    - 未设置 O_CLOEXEC 的 fd 会在 exec 后继承到新程序，容易泄漏；建议用 pipe2 的 O_CLOEXEC 或 fcntl(F_SETFD, FD_CLOEXEC)。
  - 双向通信的替代
    - 简单父子通信：两条 pipe；进程间、跨主机、复杂拓扑：优先考虑套接字（AF_UNIX/AF_INET）。

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -std=c11 -o pipe1 pipe_child_writes_parent_reads.c
  ./pipe1

  gcc -Wall -Wextra -O2 -std=c11 -o duplex pipe_duplex_parent_child.c
  ./duplex
  ```

- 小结
  - 无名管道是最基础的 IPC：单向、仅限亲缘关系、基于内核缓冲；关键是“正确关闭未用端”和理解阻塞/EOF/SIGPIPE 语义。
  - 双向通信需两条管道；更通用的跨进程/跨主机通信建议使用套接字。

## 二、无名管道进阶：fd 继承与关闭、阻塞/EOF/SIGPIPE、多个子进程写入、管道容量

- 摘要
  - 无名管道经 pipe 创建后返回 fd[2]（fd[0]读、fd[1]写），fork 后父子进程均继承这对描述符。
  - 单工通信：一端读、一端写；同一进程不应同时既读又写该管道（双向需两条管道）。
  - 使用要点：在各自进程中尽早关闭“未使用的那端”，否则影响 EOF 判定与阻塞行为。
  - 读写特性：空管道 read 阻塞；满管道 write 阻塞；所有写端关闭→read 返回 0（EOF）；所有读端关闭→write 触发 SIGPIPE 且返回 -1/EPIPE。
  - 可由父进程与多个子进程共享同一写端，注意写入原子性与输出交错；Linux 典型管道容量为 64 KiB。

- 重点
  - 尽早在各自进程 close 未用端（父读子写：父 close 写端、子 close 读端；反之亦然）
  - 判定：read 返回 0 为“所有写端关闭”的 EOF；write 时若无读端→SIGPIPE + EPIPE
  - 多生产者写同一管道会交错；保证单次 write ≤ PIPE_BUF（Linux 通常 4096 字节）可原子写入
  - 管道容量（Linux 通常 65536 字节）满时 write 阻塞；空时 read 阻塞（默认阻塞模式）
  - 双向通信请使用两条管道或套接字

- API 速览
  - int pipe(int fd[2]); 头文件 <unistd.h>
  - int pipe2(int fd[2], int flags); 可加 O_NONBLOCK、O_CLOEXEC（<fcntl.h>）
  - ssize_t read(int fd, void* buf, size_t n); 0 表示 EOF
  - ssize_t write(int fd, const void* buf, size_t n); 无读端→-1/EPIPE 且触发 SIGPIPE
  - int close(int fd); 建议在 fork 后各自关闭未用端

- 示例 1：打印 fd 编号并进行单向通信（父读、子写）
  ```c
  // file: pipe_fd_print_and_basic.c
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <sys/types.h>
  #include <stdlib.h>

  int main(void) {
      int fd[2];
      if (pipe(fd) == -1) { perror("pipe"); return 1; }
      printf("pipe fds: rd=%d, wr=%d\n", fd[0], fd[1]);

      pid_t pid = fork();
      if (pid < 0) { perror("fork"); return 1; }
      if (pid == 0) {
          // 子进程：写
          close(fd[0]); // 关闭读端
          const char* msg = "child line\n";
          for (int i = 0; i < 5; ++i) {
              if (write(fd[1], msg, strlen(msg)) < 0) { perror("write"); break; }
              sleep(1);
          }
          close(fd[1]);
          _exit(0);
      } else {
          // 父进程：读
          close(fd[1]); // 关闭写端
          char buf[128];
          for (;;) {
              ssize_t n = read(fd[0], buf, sizeof(buf)-1);
              if (n < 0) { perror("read"); break; }
              if (n == 0) { puts("EOF"); break; }
              buf[n] = '\0';
              fputs(buf, stdout);
          }
          close(fd[0]);
      }
      return 0;
  }
  ```

- 示例 2：父进程读取，两个子进程写入同一管道（错峰避免同时到达）
  ```c
  // file: pipe_multi_children_write.c
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <stdlib.h>
  #include <sys/types.h>

  int main(void) {
      int fd[2];
      if (pipe(fd) == -1) { perror("pipe"); return 1; }

      for (int i = 0; i < 2; ++i) {
          pid_t pid = fork();
          if (pid < 0) { perror("fork"); return 1; }
          if (pid == 0) {
              // 子进程：写
              close(fd[0]);
              // 不同子进程用不同延迟，减少交错
              if (i == 0) usleep(900000); else usleep(300000);
              char msg[64];
              snprintf(msg, sizeof(msg), "child%d says hi\n", i);
              for (int k = 0; k < 5; ++k) {
                  if (write(fd[1], msg, strlen(msg)) < 0) { perror("write"); break; }
                  usleep(200000);
              }
              close(fd[1]);
              _exit(0);
          }
      }

      // 父进程：读
      close(fd[1]);
      char buf[256];
      for (;;) {
          ssize_t n = read(fd[0], buf, sizeof(buf)-1);
          if (n < 0) { perror("read"); break; }
          if (n == 0) break; // 所有写端关闭 → EOF
          buf[n] = '\0';
          fputs(buf, stdout);
      }
      close(fd[0]);
      return 0;
  }
  ```

- 示例 3：演示 SIGPIPE 与 EPIPE（读端关闭后写入）
  ```c
  // file: pipe_sigpipe_demo.c
  #include <signal.h>
  #include <stdio.h>
  #include <string.h>
  #include <unistd.h>
  #include <stdlib.h>
  #include <errno.h>

  int main(void) {
      int fd[2];
      if (pipe(fd) == -1) { perror("pipe"); return 1; }

      // 忽略 SIGPIPE，便于以返回值方式观测 EPIPE
      signal(SIGPIPE, SIG_IGN);

      pid_t pid = fork();
      if (pid < 0) { perror("fork"); return 1; }
      if (pid == 0) {
          // 子进程：写 → 先让父把读端关掉
          close(fd[0]);
          sleep(1);
          ssize_t n = write(fd[1], "x", 1);
          if (n < 0) perror("write (expected EPIPE)");
          close(fd[1]);
          _exit(0);
      } else {
          // 父进程：立即关闭读端，导致子进程写入时 EPIPE
          close(fd[0]);
          close(fd[1]); // 父也不写
          wait(NULL);
      }
      return 0;
  }
  ```

- 示例 4：非阻塞管道与 EAGAIN
  ```c
  // file: pipe_nonblock.c
  #include <fcntl.h>
  #include <stdio.h>
  #include <unistd.h>
  #include <errno.h>

  int main(void) {
      int fd[2];
      if (pipe2(fd, O_NONBLOCK) == -1) { perror("pipe2"); return 1; }

      char buf[8];
      ssize_t r = read(fd[0], buf, sizeof(buf));
      if (r < 0 && errno == EAGAIN) puts("read: EAGAIN (no data)");

      // 连续写直到满（示意：实际应循环并检查 EAGAIN）
      char x[4096] = {0};
      for (;;) {
          ssize_t w = write(fd[1], x, sizeof(x));
          if (w < 0 && errno == EAGAIN) { puts("write: EAGAIN (pipe full)"); break; }
      }

      close(fd[0]); close(fd[1]);
      return 0;
  }
  ```

- 行为与实践细节
  - 关闭时机
    - 父读子写：父 close(fd[1])、子 close(fd[0])；父写子读反之
    - 多个子进程写同一管道时，父进程收到 EOF 必须是“所有子进程和父进程自身的写端都关闭”后才会出现
  - 原子性与交错
    - 单次 write 长度 ≤ PIPE_BUF（Linux 通常 4096）可原子写入，不与其他写交叉；超过可能被拆分
  - 阻塞与容量
    - Linux 常见容量 65536 字节；空→read 阻塞，满→write 阻塞（阻塞模式）
  - 安全输出
    - 将 read 返回的 n 字节补 '\0' 再作为字符串打印；注意 read/write 可能部分完成，需循环处理
  - 错误与信号
    - 无读端写入→SIGPIPE + EPIPE；可忽略 SIGPIPE 并检查 errno，避免进程被默认终止
  - 双向通信
    - 使用两条无名管道（父→子、子→父），或直接使用（本地）UNIX 域套接字

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -std=c11 -o p1 pipe_fd_print_and_basic.c
  gcc -Wall -Wextra -O2 -std=c11 -o p2 pipe_multi_children_write.c
  gcc -Wall -Wextra -O2 -std=c11 -o p3 pipe_sigpipe_demo.c
  gcc -Wall -Wextra -O2 -std=c11 -o p4 pipe_nonblock.c
  ```

- 小结
  - 正确关闭未用端、理解阻塞/EOF/SIGPIPE，是使用无名管道的关键。
  - 多生产者写入需考虑写原子性与交错；需要双向通信则应当使用“两条管道”或套接字。
  - 如需避免阻塞，可结合 O_NONBLOCK 与 select/poll/epoll 实现事件驱动的读写。



## 三、有名管道 FIFO：概念、mkfifo、open/读写阻塞语义与示例

- 摘要
  - 有名管道（FIFO）是进程间通信（IPC）的一种特殊“文件”，通过路径名在文件系统中可见，但数据在内核内存中流动。
  - 适用于非亲缘关系进程之间的通信；与无名管道一样，单工通信（单向流动），要双向需两条 FIFO。
  - 采用“文件IO”接口（open/read/write/close）而非标准IO（fopen/fprintf 等），避免缓冲带来的不可预期行为。
  - 创建：mkfifo(path, mode)；读写：open(path, O_RDONLY|O_WRONLY[|O_NONBLOCK]) + read/write；完成后可 unlink(path)。

- 关键特性与行为
  - 文件系统可见
    - ls -l 可见类型 “p”；节点存在于磁盘目录树，但实际数据缓冲在内核。
    - 节点持久，需手动 unlink 删除（与无名管道不同）。
  - 单工
    - 一端读、一端写；若需要双向通信，建立两条不同路径的 FIFO（如 /tmp/c2s.fifo 和 /tmp/s2c.fifo）。
  - 打开（open）的阻塞语义（默认阻塞）
    - 打开只读 O_RDONLY：若当前没有任何写端打开，则 open 会阻塞，直到某个进程以写端打开；O_NONBLOCK 下会立即成功，后续 read 在“无写端”时返回 0（像 EOF）。
    - 打开只写 O_WRONLY：若当前没有任何读端打开，则 open 会阻塞；O_NONBLOCK 下会立刻失败，返回 -1 且 errno=ENXIO。
    - 打开读写 O_RDWR：POSIX 允许，但会改变语义（该进程同时是读/写端，避免 open 阻塞）。不建议用于真实的生产通信，因为 EOF/可读性判定会变得不直观；教学/测试可用。
  - 读/写时的典型语义
    - read：
      - 管道中有数据→返回已读字节数（可能小于请求长度）。
      - 管道中无数据但仍有写端存在→阻塞（阻塞模式）。
      - 没有任何写端存在→返回 0（EOF）。
    - write：
      - 有读端→写入（可能分多次，需循环处理部分写）。
      - 没有任何读端→触发 SIGPIPE 并使 write 返回 -1，errno=EPIPE（默认 SIGPIPE 终止进程；可忽略该信号并检查返回值）。
    - 原子性：单次 write 长度 ≤ PIPE_BUF（POSIX 至少 512，Linux 通常 4096）对同一 FIFO 具原子性，避免多写者交错。
  - 非阻塞 I/O 与复用
    - 使用 O_NONBLOCK 或后续 fcntl(O_NONBLOCK) 可改为非阻塞；配合 select/poll/epoll 监控可用性事件。
  - 权限与 umask
    - mkfifo 的 mode 会受进程 umask 影响；常用 0666（按需再配合文件权限/目录权限/组策略）。
  - 平台与路径注意
    - 请在本地 Linux 文件系统上创建（如 /tmp 或 /var/run/yourapp）；不要在 Windows 共享挂载目录上创建（可能不支持 FIFO 类型）。

- API 速览
  - 创建
    - int mkfifo(const char* pathname, mode_t mode);
    - 头文件：#include <sys/stat.h>（也可 <sys/types.h>）
    - 成功 0，失败 -1（EEXIST 表示已存在可忽略或先 unlink）
  - 打开
    - int open(const char* path, int flags); // O_RDONLY 或 O_WRONLY，可选 O_NONBLOCK|O_CLOEXEC
  - 读写与关闭
    - ssize_t read(int fd, void* buf, size_t n);
    - ssize_t write(int fd, const void* buf, size_t n);
    - int close(int fd);
    - int unlink(const char* path); // 删除 FIFO 节点

- 示例 1：写端（创建 FIFO，阻塞等待读端上线后写入）
  ```c
  // file: fifo_writer.c
  #define _POSIX_C_SOURCE 200809L
  #include <errno.h>
  #include <fcntl.h>
  #include <signal.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/stat.h>
  #include <sys/types.h>
  #include <unistd.h>

  static const char* FIFO_PATH = "/tmp/my_fifo_demo";

  int main(void) {
      // 忽略 SIGPIPE，改用返回值检查 EPIPE
      signal(SIGPIPE, SIG_IGN);

      // 创建 FIFO（若已存在则忽略）
      if (mkfifo(FIFO_PATH, 0666) == -1 && errno != EEXIST) {
          perror("mkfifo");
          return 1;
      }

      // 仅写方式打开：若无读端，open 将阻塞（无 O_NONBLOCK）
      int fd = open(FIFO_PATH, O_WRONLY | O_CLOEXEC);
      if (fd == -1) { perror("open writer"); return 1; }

      char line[256];
      fprintf(stdout, "writer: type lines, Ctrl-D to quit\n");
      while (fgets(line, sizeof(line), stdin)) {
          size_t len = strlen(line);
          size_t off = 0;
          while (off < len) {
              ssize_t n = write(fd, line + off, len - off);
              if (n < 0) {
                  if (errno == EINTR) continue;
                  if (errno == EPIPE) { fprintf(stderr, "writer: no readers (EPIPE)\n"); goto out; }
                  perror("write");
                  goto out;
              }
              off += (size_t)n;
          }
      }

  out:
      close(fd);
      // 是否删除 FIFO 视场景而定；多个进程共享使用时不要随意 unlink
      // unlink(FIFO_PATH);
      return 0;
  }
  ```

- 示例 2：读端（阻塞打开，按行打印；收到 EOF 时退出）
  ```c
  // file: fifo_reader.c
  #define _POSIX_C_SOURCE 200809L
  #include <errno.h>
  #include <fcntl.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/stat.h>
  #include <sys/types.h>
  #include <unistd.h>

  static const char* FIFO_PATH = "/tmp/my_fifo_demo";

  int main(void) {
      // 确保 FIFO 存在（可选）
      if (mkfifo(FIFO_PATH, 0666) == -1 && errno != EEXIST) {
          perror("mkfifo");
          return 1;
      }

      // 仅读方式打开：若无写端，open 将阻塞（无 O_NONBLOCK）
      int fd = open(FIFO_PATH, O_RDONLY | O_CLOEXEC);
      if (fd == -1) { perror("open reader"); return 1; }

      char buf[512];
      for (;;) {
          ssize_t n = read(fd, buf, sizeof(buf));
          if (n < 0) {
              if (errno == EINTR) continue;
              perror("read");
              break;
          }
          if (n == 0) { // 所有写端关闭 → EOF
              fprintf(stdout, "reader: EOF\n");
              break;
          }
          fwrite(buf, 1, (size_t)n, stdout);
          fflush(stdout);
      }

      close(fd);
      // unlink(FIFO_PATH); // 仅当你是资源拥有者且不再需要
      return 0;
  }
  ```

- 示例 3：非阻塞打开的典型返回
  ```c
  // file: fifo_nonblock_open.c
  #define _POSIX_C_SOURCE 200809L
  #include <errno.h>
  #include <fcntl.h>
  #include <stdio.h>
  #include <sys/stat.h>
  #include <unistd.h>

  static const char* FIFO_PATH = "/tmp/my_fifo_nb";

  int main(void) {
      if (mkfifo(FIFO_PATH, 0666) == -1 && errno != EEXIST) { perror("mkfifo"); return 1; }

      int fr = open(FIFO_PATH, O_RDONLY | O_NONBLOCK);
      if (fr == -1) { perror("open O_RDONLY|O_NONBLOCK"); return 1; }
      puts("opened reader nonblock OK");

      int fw = open(FIFO_PATH, O_WRONLY | O_NONBLOCK);
      if (fw == -1 && errno == ENXIO) {
          puts("open writer nonblock failed with ENXIO (no reader yet)");
      }

      close(fr); if (fw != -1) close(fw);
      unlink(FIFO_PATH);
      return 0;
  }
  ```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -std=c11 -o fifo_writer  fifo_writer.c
  gcc -Wall -Wextra -O2 -std=c11 -o fifo_reader  fifo_reader.c
  gcc -Wall -Wextra -O2 -std=c11 -o fifo_nb_open fifo_nonblock_open.c

  # 终端1
  ./fifo_reader
  # 终端2
  ./fifo_writer
  ```

- 实践要点与常见坑
  - 不要用标准 IO 操作 FIFO（除非你非常明确其缓冲策略）
    - stdio 可能行缓冲/全缓冲，导致数据“看起来延迟”；用 read/write 更直观。
  - 处理好 open 的阻塞
    - 写端需要读端先行（或使用 O_NONBLOCK 并处理 ENXIO）；读端需要写端先行（或 NONBLOCK 并接受 read=0）。
  - 处理部分读/写与 EINTR
    - 循环 read/write；被信号打断（EINTR）需重试。
  - 处理 EPIPE/SIGPIPE
    - 写无读端→SIGPIPE/EPIPE；可 signal(SIGPIPE, SIG_IGN) 并用返回值判错。
  - 多写者的交错
    - 单次 write ≤ PIPE_BUF 可保证原子；更长消息建议应用层 framing（如以换行、长度头部等）。
  - 清理
    - 只在资源拥有方负责 unlink；多程序共享的 FIFO 不要随意删除。
  - 放置位置
    - 建议 /tmp 或受控目录；避免放在不支持 FIFO 的挂载（如 Windows 共享盘）。

- 小结
  - FIFO 让彼此独立的进程通过路径名实现单向消息流；掌握 mkfifo、open 的阻塞语义，以及 read/write/SIGPIPE/PIPE_BUF 等细节，基本即可胜任常见的本机 IPC 需求。



## 四、FIFO 进阶：打开模式、阻塞/非阻塞语义与数据完整性（PIPE_BUF）

- 摘要
  - FIFO 只建议用只读（O_RDONLY）或只写（O_WRONLY）方式打开；避免 O_RDWR 造成语义混乱与“不可预期”结果。
  - 默认 open 是阻塞的：读端会等写端出现、写端会等读端出现；非阻塞（O_NONBLOCK）会改变 open/读/写 的返回语义。
  - 多进程并发写入时，单次写入长度 ≤ PIPE_BUF 可保证原子性（“要么全部写入，要么一个字节不写入”）；超过 PIPE_BUF 不能保证消息完整性。
  - 实践中推荐阻塞打开，非阻塞需配合错误码（ENXIO/EAGAIN/EPIPE）与事件复用（select/poll/epoll）处理。

- 重点
  - 打开模式：O_RDONLY 或 O_WRONLY；默认阻塞；O_NONBLOCK 改变行为
  - 非阻塞典型返回：写端无读者→open 失败 ENXIO；读无数据→read -1/EAGAIN；无写者→read 0（EOF）
  - 数据完整性：单次 write ≤ PIPE_BUF 原子；建议查询实际 PIPE_BUF 并据此切分消息
  - 错误处理：EINTR 重试；EAGAIN 重试或等待；写端无读者 write -1/EPIPE 且触发 SIGPIPE（可忽略信号并检查返回值）

- 打开与读写的阻塞/非阻塞语义速查
  - O_RDONLY 打开（阻塞）：若无写端，open 阻塞，直至有写端打开
  - O_WRONLY 打开（阻塞）：若无读端，open 阻塞，直至有读端打开
  - O_RDONLY | O_NONBLOCK：
    - open 立即成功（即使无写端）
    - read：
      - 无数据且至少一侧有写端→-1/EAGAIN
      - 所有写端均关闭→0（EOF）
  - O_WRONLY | O_NONBLOCK：
    - 若无读端→open 立刻失败 -1/ENXIO
    - 有读端但管道满→write -1/EAGAIN
    - 无读端→write -1/EPIPE 并触发 SIGPIPE（默认终止）

- 示例 1：阻塞 vs 非阻塞的 open 行为对比（读端）
  ```c
  // file: fifo_block_vs_nonblock_reader.c
  #define _POSIX_C_SOURCE 200809L
  #include <errno.h>
  #include <fcntl.h>
  #include <stdio.h>
  #include <sys/stat.h>
  #include <unistd.h>

  static const char* P = "/tmp/fifo_demo_block";

  int main(void) {
      mkfifo(P, 0666); // 已存在则忽略
      // 1) 阻塞打开：若无写端，将在 open 处阻塞
      // int fd = open(P, O_RDONLY | O_CLOEXEC);

      // 2) 非阻塞打开：即使无写端也会立即成功
      int fd = open(P, O_RDONLY | O_NONBLOCK | O_CLOEXEC);

      if (fd == -1) { perror("open"); return 1; }
      puts("after open (reader)");
      char buf[64];
      ssize_t n = read(fd, buf, sizeof(buf));
      if (n < 0 && errno == EAGAIN) puts("read: EAGAIN (no data yet)");
      else if (n == 0) puts("read: EOF (no writers)");
      else if (n > 0) write(STDOUT_FILENO, buf, (size_t)n);
      close(fd);
      return 0;
  }
  ```

- 示例 2：非阻塞写端的 ENXIO/EAGAIN 与 EPIPE
  ```c
  // file: fifo_nonblock_writer_semantics.c
  #define _POSIX_C_SOURCE 200809L
  #include <errno.h>
  #include <signal.h>
  #include <stdio.h>
  #include <string.h>
  #include <sys/stat.h>
  #include <unistd.h>
  #include <fcntl.h>

  static const char* P = "/tmp/fifo_demo_nb";

  int main(void) {
      signal(SIGPIPE, SIG_IGN); // 避免默认终止，改查返回值
      mkfifo(P, 0666);

      int fd = open(P, O_WRONLY | O_NONBLOCK | O_CLOEXEC);
      if (fd == -1) {
          if (errno == ENXIO) { puts("open: ENXIO (no readers)"); return 0; }
          perror("open"); return 1;
      }

      char msg[8192] = "hello\n"; // 故意较大，便于测试 EAGAIN
      ssize_t n = write(fd, msg, sizeof(msg));
      if (n < 0) {
          if (errno == EAGAIN) puts("write: EAGAIN (pipe full)");
          else if (errno == EPIPE) puts("write: EPIPE (no readers at write time)");
          else perror("write");
      } else {
          printf("write: %zd bytes\n", n);
      }
      close(fd);
      return 0;
  }
  ```

- 示例 3：消息完整性（PIPE_BUF）与两写者并发
  ```c
  // file: fifo_atomicity_two_writers.c
  #define _POSIX_C_SOURCE 200809L
  #include <errno.h>
  #include <fcntl.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/stat.h>
  #include <sys/types.h>
  #include <sys/wait.h>
  #include <unistd.h>

  static const char* P = "/tmp/fifo_atomicity";
  static long pipe_buf(int fd) {
      long v = fpathconf(fd, _PC_PIPE_BUF);
      return v > 0 ? v : 4096; // 回退
  }

  static void writer(const char* tag, size_t msg_len) {
      int fd = open(P, O_WRONLY);
      if (fd == -1) { perror("open writer"); _exit(1); }
      char* msg = malloc(msg_len);
      memset(msg, '-', msg_len);
      // 添加可识别前缀/后缀
      size_t prefix = snprintf(msg, msg_len, "[%s]", tag);
      if (prefix < msg_len) memset(msg + msg_len - 1, '\n', 1);

      for (int i = 0; i < 50; ++i) {
          size_t off = 0;
          while (off < msg_len) {
              ssize_t n = write(fd, msg + off, msg_len - off);
              if (n < 0 && errno == EINTR) continue;
              if (n < 0) { perror("write"); free(msg); close(fd); _exit(1); }
              off += (size_t)n;
          }
          usleep(1000);
      }
      free(msg);
      close(fd);
      _exit(0);
  }

  int main(void) {
      unlink(P); mkfifo(P, 0666);
      int fr = open(P, O_RDONLY | O_CLOEXEC);
      if (fr == -1) { perror("open reader"); return 1; }

      // 查询 PIPE_BUF
      long pb = pipe_buf(fr);
      fprintf(stderr, "PIPE_BUF=%ld\n", pb);

      // 启动两个写者：一个小于等于 PIPE_BUF（原子），一个远大于（可能交错）
      pid_t w1 = fork();
      if (w1 == 0) writer("A", (size_t)(pb <= 0 ? 4096 : pb));     // 原子边界
      pid_t w2 = fork();
      if (w2 == 0) writer("B", (size_t)(pb * 2));                  // 非原子，易交错

      // 从 FIFO 连续读取，观察是否交错
      char buf[8192];
      for (;;) {
          ssize_t n = read(fr, buf, sizeof(buf));
          if (n < 0 && errno == EINTR) continue;
          if (n <= 0) break;
          write(STDOUT_FILENO, buf, (size_t)n);
      }
      close(fr);
      waitpid(w1, NULL, 0);
      waitpid(w2, NULL, 0);
      return 0;
  }
  ```

  - 预期现象
    - 写者 A 的每条消息长度 ≤ PIPE_BUF，读到的每条消息不会与其他写者交叉（原子性保证）。
    - 写者 B 的消息超出 PIPE_BUF，可能被拆分并与 A/B 的其他写入交错，出现“穿插/混排”。

- 实务建议
  - 默认用阻塞打开（更简单、直观）；非阻塞需要配合事件复用与错误码处理（ENXIO/EAGAIN/EPIPE）。
  - 设计消息协议（帧）：控制单次 write 长度 ≤ PIPE_BUF；或应用层做长度前缀/分片重组。
  - 查询实际 PIPE_BUF（fpathconf(fd, _PC_PIPE_BUF)）而非硬编码 4 KiB，以适配平台差异。
  - 忽略 SIGPIPE 并检查 write 返回值，避免进程被默认终止；EINTR 统一重试。
  - 使用 O_CLOEXEC 防止描述符泄漏到 exec 后的子进程；必要时配合权限/umask 与放置位置（/tmp 等）。

- 小结
  - FIFO 的打开模式与阻塞语义直接决定程序行为；理解非阻塞下的 ENXIO/EAGAIN/EPIPE 至关重要。
  - 并发写入的数据完整性依赖 PIPE_BUF 原子性；控制单次写入长度或自定义帧协议是工程最佳实践。


## 五、进程间通信（IPC）之内存映射 mmap：概念、API、注意事项与实战

- 摘要
  - 内存映射（mmap）将文件（或匿名页）映射到进程虚拟地址空间，进程像访问内存一样读写，从而减少拷贝与系统调用，提高 IPC 效率。
  - 非亲缘关系 IPC：使用“文件映射”（普通文件或 POSIX 共享内存对象）。
  - 亲缘关系 IPC（如 fork 后父子/兄弟）：可用“匿名共享映射”（MAP_ANONYMOUS + MAP_SHARED）。
  - 关键点：权限与 flags 匹配、文件尺寸与页大小、同步可见性（msync/内核回刷）与并发同步。

- 关键概念
  - 文件映射：将磁盘文件的一段映射为内存；多进程映射同一底层对象（同路径或同 shm 名）+ MAP_SHARED → 彼此可见。
  - 匿名映射：无文件后端，通常与 fork 配合；指定 MAP_ANONYMOUS 且 fd=-1。
  - 可见性与同步：
    - MAP_SHARED：写入页缓存后对其他映射者可见；是否落盘取决于内核回写或显式 msync。
    - MAP_PRIVATE：写时复制（COW），对他人不可见，适合加速单进程文件访问而非 IPC。

- mmap 原型与参数
  - void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
    - addr：建议传 NULL 让内核选择地址；
    - length：映射字节数（实际按页对齐）；
    - prot：PROT_READ | PROT_WRITE | PROT_EXEC | PROT_NONE（必须 ≤ 打开文件权限）；
    - flags：MAP_SHARED（IPC 用）或 MAP_PRIVATE；可叠加 MAP_ANONYMOUS（匿名映射，fd=-1）、MAP_FIXED（危险）、MAP_POPULATE 等；
    - fd：文件描述符；匿名映射时为 -1；
    - offset：文件偏移，必须是页面大小的整数倍；
  - 返回：成功返回首地址；失败返回 MAP_FAILED（(void*)-1），并置 errno。

- 常见注意事项（高频坑）
  - 打开权限匹配：若映射 PROT_WRITE，fd 必须以 O_RDWR 打开；O_RDONLY + PROT_WRITE → EACCES。
  - 文件大小不可为 0 且应覆盖到将访问的范围；否则访问超出文件尾可能 SIGBUS（“总线错误”）。
    - 扩容：ftruncate(fd, size) 先调整文件大小。
  - 页对齐：offset 必须是 page size 的整数倍（sysconf(_SC_PAGESIZE) 查询）。
  - 共享 vs 私有：IPC 选 MAP_SHARED；MAP_PRIVATE 为 COW，不共享修改。
  - 资源释放：munmap(addr, length)；关闭 fd；必要时 unlink（普通文件/共享内存对象）。
  - 同步行为：
    - 让其他进程看到内存写入无需 msync（对 MAP_SHARED 来说是同一页缓存）；但要持久化到磁盘需 msync。
    - 并发协调需同步原语（futex、POSIX 信号量、pthread 进程间互斥/条件变量等，需 PTHREAD_PROCESS_SHARED）。
  - 安全与可移植：尽量避免 MAP_FIXED；使用 O_CLOEXEC 防 FD 泄漏；注意 umask 影响权限。

---

### 示例 1：文件映射（非亲缘关系进程 IPC）

两个独立进程通过同一文件进行共享（MAP_SHARED）。写端确保文件长度足够，写内存后可 msync 刷盘（可选）。

```c name=mmap_file_writer.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

static const char* FILE_PATH = "/tmp/mmap_ipc_demo.bin";
static const size_t MAP_LEN  = 4096;

int main(void) {
    int fd = open(FILE_PATH, O_RDWR | O_CREAT | O_CLOEXEC, 0666);
    if (fd < 0) { perror("open"); return 1; }

    // 确保文件长度覆盖映射范围
    if (ftruncate(fd, (off_t)MAP_LEN) < 0) { perror("ftruncate"); close(fd); return 1; }

    void* addr = mmap(NULL, MAP_LEN, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    // 写入共享区域（演示）
    const char* msg = "hello from writer via mmap\n";
    size_t n = strlen(msg);
    memcpy(addr, msg, n);

    // 可选：将修改落盘（非必须，为了持久化）
    if (msync(addr, MAP_LEN, MS_SYNC) < 0) { perror("msync"); }

    printf("writer: wrote %zu bytes\n", n);

    munmap(addr, MAP_LEN);
    close(fd);
    return 0;
}
```

```c name=mmap_file_reader.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

static const char* FILE_PATH = "/tmp/mmap_ipc_demo.bin";
static const size_t MAP_LEN  = 4096;

int main(void) {
    int fd = open(FILE_PATH, O_RDONLY | O_CLOEXEC);
    if (fd < 0) { perror("open"); return 1; }

    void* addr = mmap(NULL, MAP_LEN, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    // 直接当作内存读取
    fwrite(addr, 1, 128, stdout); // 简单示例：读前 128 字节
    putchar('\n');

    munmap(addr, MAP_LEN);
    close(fd);
    return 0;
}
```

- 说明
  - writer 需 O_RDWR 打开并 ftruncate 至 MAP_LEN；reader 可 O_RDONLY。
  - 同映射对象 + MAP_SHARED → 修改对方可见；是否持久化由内核策略或 msync 决定。

---

### 示例 2：匿名共享映射 + fork（亲缘关系 IPC）

父子/兄弟进程共享匿名页，无需文件后端。

```c name=mmap_anonymous_shared_fork.c
#define _POSIX_C_SOURCE 200809L
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void) {
    size_t len = 4096;
    char* p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (p == MAP_FAILED) { perror("mmap"); return 1; }

    strcpy(p, "message from parent");

    pid_t pid = fork();
    if (pid < 0) { perror("fork"); munmap(p, len); return 1; }
    if (pid == 0) {
        // 子进程读取父进程写入的内容
        printf("child sees: %s\n", p);
        strcpy(p, "reply from child");
        _exit(0);
    }

    wait(NULL);
    printf("parent sees: %s\n", p);
    munmap(p, len);
    return 0;
}
```

- 说明
  - MAP_SHARED | MAP_ANONYMOUS 为亲缘关系共享；无文件、fd=-1、offset=0。
  - 仍需同步手段确保可见性的时序（这里用 wait() 简化）。

---

### 示例 3：POSIX 共享内存对象（shm_open）

无亲缘关系 IPC 的常用方案：shm_open 创建设备下的共享对象（/dev/shm 或实现相关），与 mmap 结合，无需普通文件路径。

```c name=shm_writer.c
#define _POSIX_C_SOURCE 200809L
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

static const char* SHM_NAME = "/shm_ipc_demo";
static const size_t LEN = 4096;

int main(void) {
    int fd = shm_open(SHM_NAME, O_CREAT | O_RDWR | O_CLOEXEC, 0666);
    if (fd < 0) { perror("shm_open"); return 1; }
    if (ftruncate(fd, (off_t)LEN) < 0) { perror("ftruncate"); close(fd); shm_unlink(SHM_NAME); return 1; }

    void* p = mmap(NULL, LEN, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); shm_unlink(SHM_NAME); return 1; }

    const char* msg = "hello from shm writer\n";
    memcpy(p, msg, strlen(msg));

    munmap(p, LEN);
    close(fd);
    // 注意：是否 shm_unlink 取决于是否要保留对象供他人继续使用
    return 0;
}
```

```c name=shm_reader.c
#define _POSIX_C_SOURCE 200809L
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

static const char* SHM_NAME = "/shm_ipc_demo";
static const size_t LEN = 4096;

int main(void) {
    int fd = shm_open(SHM_NAME, O_RDONLY | O_CLOEXEC, 0666);
    if (fd < 0) { perror("shm_open"); return 1; }

    void* p = mmap(NULL, LEN, PROT_READ, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    fwrite(p, 1, 128, stdout);
    putchar('\n');

    munmap(p, LEN);
    close(fd);
    // 由拥有者选择 shm_unlink(SHM_NAME) 清理
    return 0;
}
```

- 说明
  - shm_open 名称以“/”开头（不含路径层级）；权限受 umask 影响。
  - shm_unlink 删除命名对象（类似 unlink 文件名），已映射的进程仍可用，所有引用关闭后内核回收。

---

### 并发同步与可见性提示
- mmap 仅提供共享存取，不提供顺序/互斥保证。多进程并发修改需同步：
  - PTHREAD_PROCESS_SHARED 的互斥/条件变量（需把 pthread_mutex_t 放在共享映射内，并用 pthread_mutexattr_setpshared 设置为 PTHREAD_PROCESS_SHARED）。
  - POSIX 信号量（sem_open/sem_post/sem_wait）。
  - eventfd/管道/消息队列用于事件通知。
- 刷新与一致性：
  - 让他进程“看见”改动通常不需 msync（共享同一页缓存），但为持久化或跨机器恢复应 msync。
  - 读取方应在同步点后再访问，以避免看到中间态。

---

### 编译与运行
```bash
# 文件映射
gcc -Wall -Wextra -O2 -std=c11 -o mmap_file_writer  mmap_file_writer.c
gcc -Wall -Wextra -O2 -std=c11 -o mmap_file_reader  mmap_file_reader.c
./mmap_file_writer
./mmap_file_reader

# 匿名共享 + fork
gcc -Wall -Wextra -O2 -std=c11 -o anon_fork mmap_anonymous_shared_fork.c
./anon_fork

# POSIX 共享内存
gcc -Wall -Wextra -O2 -std=c11 -o shm_writer shm_writer.c -lrt 2>/dev/null || gcc -Wall -Wextra -O2 -std=c11 -o shm_writer shm_writer.c
gcc -Wall -Wextra -O2 -std=c11 -o shm_reader shm_reader.c -lrt 2>/dev/null || gcc -Wall -Wextra -O2 -std=c11 -o shm_reader shm_reader.c
./shm_writer
./shm_reader
```

- 一些系统需要链接 -lrt（老旧 glibc）；现代发行版往往不需要，上述命令已做兼容尝试。

---

### 小结
- 使用 mmap 做 IPC 的关键是：正确的 PROT/flags、确保文件大小、共享（MAP_SHARED）与匿名映射的取舍、以及必要的并发同步。
- 文件映射适合无亲缘关系；匿名共享映射适合 fork 家族；POSIX 共享内存是更“干净”的无路径选择。
- 防坑清单：O_RDONLY+PROT_WRITE=EACCES；offset 非页对齐→EINVAL；文件过小→SIGBUS；MAP_PRIVATE 不共享修改；注意 munmap/close/unlink 的时机。



## 六、mmap 进阶与易错点：权限/flags、关闭 fd、映射长度与偏移、文件大小关系、SIGBUS vs SIGSEGV、健壮用法

- 摘要
  - 深入梳理 mmap 在进程间通信与本地文件访问中的关键注意事项：权限匹配、MAP_SHARED/PRIVATE 差异、映射后是否可立即关闭 fd、映射长度与文件大小/页大小的关系、偏移对齐约束，以及越界访问引发的 SIGBUS 与 SIGSEGV 区别。
  - 提供健壮的错误处理建议与示例代码，帮助避免“段错误/总线错误/非法参数”类问题。

- 核心要点速览
  - 权限匹配
    - 共享映射（MAP_SHARED）且需要写时：fd 必须以 O_RDWR 打开；PROT_WRITE 不能搭配 O_RDONLY（否则 EACCES）。
    - 私有映射（MAP_PRIVATE）可用 O_RDONLY 打开，即便 PROT_WRITE 也只是在内存写（COW），不会回写磁盘。
  - fd 与映射生命周期
    - 成功 mmap 后可立即 close(fd)；映射区仍然有效，直到 munmap。
  - 映射长度与文件大小
    - length 必须 > 0（否则 EINVAL）。
    - 可将 length 设为大于文件大小，但“超出文件大小的部分不是随便可用”：读写映射页中“落在文件范围之外”的地址会触发 SIGBUS。
  - 偏移对齐
    - offset 必须是页大小（通常 4 KiB）的整数倍（否则 EINVAL）。
  - 访问越界的两种错误
    - 访问“映射区范围之外” → SIGSEGV（段错误）。
    - 访问“映射区内，但落在文件实际大小之外的页”且为 MAP_SHARED/文件后端 → SIGBUS（总线错误）。
  - 错误检查
    - mmap 返回 MAP_FAILED（(void*)-1）且置 errno；务必检查后再使用。
    - 读/写访问前，确保 length、offset、文件大小与访问范围的逻辑关系正确。

- 概念补充与行为梳理
  - MAP_SHARED vs MAP_PRIVATE
    - MAP_SHARED：对映射内存的写入对其他映射者可见，并按内核策略回写文件；需要持久化可用 msync。
    - MAP_PRIVATE：写时复制（COW），更改仅对本进程可见，不回写文件，即便 msync 通常也不会把私有改动落盘。
  - 关闭 fd 的影响
    - 只要 mmap 成功，后续对映射内存的读写与 fd 是否关闭无关；munmap 才是释放映射的关键。
  - 文件大小的确定
    - 推荐 fstat 获取 st_size；或用 lseek(fd, 0, SEEK_END) 获取长度后再复位 lseek(fd, 0, SEEK_SET)。
  - 页与对齐
    - 映射粒度按页；offset 必须页对齐。长度内部由内核按页向上对齐分配映射，但你仍应该把 length 设为“你计划访问的上界对齐到页”的大小。

- 示例 1：MAP_SHARED 写入后关闭 fd 仍然生效（并可持久化）
```c name=mmap_shared_write_after_close.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

static const char* P = "/tmp/mmap_shared_demo.bin";
static const size_t LEN = 4096;

int main(void) {
    int fd = open(P, O_RDWR | O_CREAT | O_CLOEXEC, 0666);
    if (fd < 0) { perror("open"); return 1; }

    // 确保文件够大，避免后续写入触发 SIGBUS
    if (ftruncate(fd, (off_t)LEN) < 0) { perror("ftruncate"); close(fd); return 1; }

    void* p = mmap(NULL, LEN, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    // 成功后可关闭 fd；映射仍有效
    close(fd);

    const char* msg = "hello via MAP_SHARED after close(fd)\n";
    memcpy(p, msg, strlen(msg));

    // 可选：同步到磁盘
    if (msync(p, LEN, MS_SYNC) < 0) perror("msync");

    munmap(p, LEN);
    return 0;
}
```

- 示例 2：MAP_PRIVATE 可写但不落盘（即使文件只读打开）
```c name=mmap_private_no_persist.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

static const char* P = "/tmp/mmap_private_demo.txt";
static const size_t LEN = 4096;

int main(void) {
    int fd = open(P, O_RDONLY | O_CLOEXEC);
    if (fd < 0) { perror("open"); return 1; }

    void* p = mmap(NULL, LEN, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    // 在私有映射上写入，不会回写文件
    memset(p, '9', 128);

    munmap(p, LEN);
    close(fd);
    return 0;
}
```

- 示例 3：offset 非页对齐将失败（EINVAL）
```c name=mmap_offset_alignment.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

int main(void) {
    const char* P = "/tmp/mmap_align.bin";
    int fd = open(P, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (fd < 0) { perror("open"); return 1; }
    ftruncate(fd, 8192);

    long pagesz = sysconf(_SC_PAGESIZE);
    off_t bad_off = 1;                        // 非页对齐
    void* p = mmap(NULL, 4096, PROT_READ, MAP_SHARED, fd, bad_off);
    if (p == MAP_FAILED) {
        perror("mmap (expected EINVAL)");
    }
    close(fd);
    return 0;
}
```

- 示例 4：length 大于文件大小；访问文件范围外引发 SIGBUS
```c name=mmap_length_gt_file_sigbus.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

static void on_sigbus(int sig) {
    (void)sig;
    write(STDERR_FILENO, "got SIGBUS\n", 11);
    _exit(2);
}

int main(void) {
    const char* P = "/tmp/mmap_sigbus.bin";
    int fd = open(P, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (fd < 0) { perror("open"); return 1; }

    // 文件只有 100 字节
    if (ftruncate(fd, 100) < 0) { perror("ftruncate"); close(fd); return 1; }

    // 映射 4096 字节（> 文件大小）
    size_t len = 4096;
    char* p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }
    close(fd);

    signal(SIGBUS, on_sigbus);

    // 访问文件范围内：OK（0..99）
    p[50] = 'A';

    // 访问映射区内但越过文件大小的区域：触发 SIGBUS
    p[200] = 'B'; // 文件大小=100，此处将导致总线错误

    munmap(p, len);
    return 0;
}
```

- 示例 5：访问映射区之外 → SIGSEGV（段错误）
```c name=mmap_out_of_range_sigsegv.c
#define _POSIX_C_SOURCE 200809L
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    size_t len = 4096;
    char* p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (p == MAP_FAILED) { perror("mmap"); return 1; }

    // 合法
    p[0] = 'x'; p[len-1] = 'y';

    // 非法：访问映射范围之外（将引发 SIGSEGV）
    volatile char c = p[len]; // 越界
    (void)c;

    munmap(p, len);
    return 0;
}
```

- 示例 6：健壮的“映射并写”流程（含尺寸/权限/错误检查）
```c name=mmap_robust_map_write.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

int main(void) {
    const char* P = "/tmp/mmap_robust.bin";
    size_t want = 8192; // 计划写入的最大范围（按页上取整更稳妥）

    int fd = open(P, O_RDWR | O_CREAT | O_CLOEXEC, 0666);
    if (fd < 0) { perror("open"); return 1; }

    // 确保文件长度 ≥ want，避免后续写触发 SIGBUS
    if (ftruncate(fd, (off_t)want) < 0) { perror("ftruncate"); close(fd); return 1; }

    void* p = mmap(NULL, want, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    // 关闭 fd（可选）
    close(fd);

    // 写入
    const char* msg = "robust write\n";
    memcpy(p, msg, strlen(msg));

    // 可选：同步
    if (msync(p, want, MS_SYNC) < 0) perror("msync");

    munmap(p, want);
    return 0;
}
```

- 实战建议与排错清单
  - 打开 & 权限
    - 需要写文件且 MAP_SHARED → open O_RDWR；仅读 → O_RDONLY。
    - O_RDONLY + PROT_WRITE + MAP_SHARED 会 EACCES；改为 O_RDWR 或改用 MAP_PRIVATE。
  - 文件大小
    - 任何将要访问的地址都必须“落在文件真实大小内的页”上，否则 SIGBUS。
    - 计划写入 → 先 ftruncate 扩容到足够大（对齐到页大小更稳妥）。
  - 偏移对齐
    - offset 必须是 pagesize 的整数倍；pagesize = sysconf(_SC_PAGESIZE)。
  - 返回值检查
    - mmap 返回 MAP_FAILED 必须立即处理；不要对失败的指针做读写。
  - 错误区分
    - EINVAL：多见于 length=0、offset 未对齐、flags/prot 组合非法等。
    - EACCES：权限不匹配（如 O_RDONLY + PROT_WRITE）。
    - SIGBUS：映射内但文件范围外访问。
    - SIGSEGV：映射区外访问或缺页等其他原因。
  - 同步与并发
    - MAP_SHARED 的修改对他进程可见，但落盘时机由内核决定；需要持久化用 msync。
    - 跨进程并发修改需要同步原语（进程共享的 pthread 互斥/条件变量、POSIX 信号量等）。

- 小结
  - 正确理解“权限/flags、fd 生命周期、长度与偏移、文件大小与页”的耦合关系，是写对 mmap 的关键。
  - 牢记：length>0、offset 按页对齐、文件大小覆盖访问范围；MAP_PRIVATE 不落盘；mmap 成功后可关 fd。
  - 出错优先级：先看 errno（MAP_FAILED/EINVAL/EACCES），再定位访问越界（SIGBUS vs SIGSEGV）。



## 七、共享内存 IPC 实战：基于文件的 MAP_SHARED 与匿名映射（MAP_ANONYMOUS | MAP_SHARED）

- 摘要
  - 用 mmap 的“文件映射 + MAP_SHARED”实现两个独立进程之间的读写通信（writer/reader）。
  - 用“匿名映射 + MAP_SHARED + fork”实现父子（血缘）进程间通信，无需文件。
  - 对比 MAP_SHARED 与 MAP_PRIVATE：仅 MAP_SHARED 的写入会被其它映射者看见；MAP_PRIVATE 为写时复制（不共享）。
  - 演示规范的资源管理（ftruncate 扩容、mmap 成功检查、munmap 释放、close/等待时序）与最简轮询同步。

- 要点速览
  - 基于文件的 IPC
    - writer：open O_RDWR|O_CREAT → ftruncate 至映射长度 → mmap(PROT_READ|PROT_WRITE, MAP_SHARED)
    - reader：open O_RDONLY → mmap(PROT_READ, MAP_SHARED)
    - 共享可见，不保证顺序/通知；示例用轮询避免读到未初始化数据。
  - 匿名共享（父子）
    - mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0)
    - fork 后父写子读或相反；无需文件。
  - 对比
    - MAP_PRIVATE：可写但不落盘且不共享（演示中不用于 IPC）。
  - 清理
    - 映射成功后可关闭 fd；结束前 munmap；文件型 IPC 可保留文件供复用或按需 unlink。

---

- 示例 1：基于文件的 writer（每秒写 1 字节）
```c name=mmap_file_ipc_writer.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

static const char* PATH = "/tmp/mmap_ipc_area.bin";
static const size_t LEN = 4096;   // 1 页
static const int    COUNT = 64;   // 演示写入字节数

int main(void) {
    int fd = open(PATH, O_RDWR | O_CREAT | O_CLOEXEC, 0666);
    if (fd < 0) { perror("open"); return 1; }

    if (ftruncate(fd, (off_t)LEN) < 0) { perror("ftruncate"); close(fd); return 1; }

    unsigned char* p = mmap(NULL, LEN, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }
    close(fd); // 映射成功后可立即关闭

    for (int i = 0; i < COUNT && i < (int)LEN; ++i) {
        p[i] = (unsigned char)('A' + (i % 26));   // 写入可见字节
        printf("writer: wrote [%d] = %c\n", i, p[i]);
        // 可选：同步到磁盘（非必须，为持久化）
        // msync(p + i, 1, MS_ASYNC);
        sleep(1);
    }

    munmap(p, LEN);
    // 可选：unlink(PATH); // 如需清理文件节点
    return 0;
}
```

- 示例 2：基于文件的 reader（轮询读取新字节）
```c name=mmap_file_ipc_reader.c
#define _POSIX_C_SOURCE 200809L
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

static const char* PATH = "/tmp/mmap_ipc_area.bin";
static const size_t LEN = 4096;

int main(void) {
    int fd = open(PATH, O_RDONLY | O_CLOEXEC);
    if (fd < 0) { perror("open"); return 1; }

    const unsigned char* p = mmap(NULL, LEN, PROT_READ, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }
    close(fd);

    size_t idx = 0;
    while (idx < LEN) {
        unsigned char v = p[idx];
        if (v != 0) {                       // 初始区域为 0，非 0 视为“已写入”
            printf("reader: read  [%zu] = %c\n", idx, v);
            ++idx;
        } else {
            usleep(100000);                 // 简单轮询；生产中请用进程间同步原语
        }
    }

    munmap((void*)p, LEN);
    return 0;
}
```

- 运行顺序建议
  - 终端1（先启动 writer，创建并扩容文件）：
    - gcc -Wall -Wextra -O2 -std=c11 -o writer mmap_file_ipc_writer.c
    - ./writer
  - 终端2（再启动 reader）：
    - gcc -Wall -Wextra -O2 -std=c11 -o reader mmap_file_ipc_reader.c
    - ./reader

- 示例 3：匿名映射 + fork（父写子读）
```c name=mmap_anonymous_fork_ipc.c
#define _POSIX_C_SOURCE 200809L
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void) {
    size_t len = 4096;
    char* p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (p == MAP_FAILED) { perror("mmap"); return 1; }

    pid_t pid = fork();
    if (pid < 0) { perror("fork"); munmap(p, len); return 1; }

    if (pid == 0) {
        // 子进程：等待父进程写入
        sleep(1);
        printf("child: got -> %s\n", p);    // 父进程写入的 C 字符串
        _exit(0);
    } else {
        // 父进程：写入共享页
        const char* msg = "hello from parent via MAP_ANONYMOUS|MAP_SHARED";
        memcpy(p, msg, strlen(msg) + 1);    // 包含 '\0'
        wait(NULL);
        munmap(p, len);
        return 0;
    }
}
```

- 编译与运行
  - gcc -Wall -Wextra -O2 -std=c11 -o anon mmap_anonymous_fork_ipc.c
  - ./anon

---

- 说明与常见问题
  - 为什么 reader 用 MAP_SHARED 但只读打开？
    - 仅读取共享内容，用 O_RDONLY 打开文件并以 PROT_READ | MAP_SHARED 映射即可；writer 负责 O_RDWR + ftruncate。
  - 为什么示例用轮询判断“非零字节”为已写？
    - 条件变量/信号量/基于 futex 的锁等同步原语更可靠；此处为最小可运行演示，避免未初始化数据被读到。
  - MAP_PRIVATE 为什么看不到对方写入？
    - 私有映射采用写时复制（COW），修改只体现在当前进程页框中，不会共享给其他进程，也不会写回文件。
  - 资源释放
    - 映射成功后可关闭 fd；最终用 munmap 释放映射。匿名映射无文件，不需要 close；父子结束前各自 munmap。
  - 边界与安全
    - 访问范围必须落在映射长度与“文件真实大小可覆盖的页”内；否则可能 SIGBUS（文件范围外）或 SIGSEGV（映射区外）。
    - 写入字符串请包含 '\0' 或基于长度打印，避免越界读取。

- 小结
  - 文件映射 + MAP_SHARED 适合非亲缘进程 IPC；匿名映射 + MAP_SHARED 适合父子/兄弟进程。
  - 注意扩容、权限与 flags 的匹配，并在需要时引入同步原语保证有序与完整性。


## 八、System V 共享内存（shm）：ftok/shmget/shmat/shmdt/shmctl 全流程、对比与示例

- 摘要
  - System V IPC 共享内存是较早期但依然可用的本机进程间通信机制，核心 API：ftok → shmget → shmat → 读写 → shmdt → shmctl(IPC_RMID)。
  - 与管道/套接字不同，共享内存是“内存区域共享”，不提供消息边界与同步，需自行加锁或信号通知。
  - 生命周期分离：进程映射/撤销（shmat/shmdt）与对象存在（shmctl IPC_RMID）。“撤销映射”不等于“删除对象”。

- 名词与对象
  - key_t（键）：标识 System V IPC 对象（共享内存/消息队列/信号量）。常用 ftok(pathname, proj_id) 生成。
  - shmid（段 ID）：由 shmget 返回，具体指向某一共享内存段。
  - nattch：当前附加（attach）到该共享段的进程计数（ipcs -m 可见）。

- 与 POSIX 共享内存/内存映射 mmap 的区别
  - System V shm：ftok/shmget/shmat/shmdt/shmctl，全局命名空间由 key/shmid 管理（ipcs/ipcrm 工具可见）。
  - POSIX shm：shm_open/shm_unlink + mmap（位于 /dev/shm），API 更现代。
  - mmap(文件/匿名)：无需 System V 内核结构，使用文件或 MAP_ANONYMOUS，常与 PTHREAD_PROCESS_SHARED 进行同步。

---

### API 速查

- 生成键
  - key_t ftok(const char* pathname, int proj_id);
    - pathname 必须存在且可访问；proj_id 通常取 1..255 的小整数（底层仅 8-bit 使用）。
    - 注意：ftok 不能绝对保证全球唯一，但在同一主机上通常足够。

- 创建/打开共享段
  - int shmget(key_t key, size_t size, int shmflg);
    - shmflg：权限位（如 0666）| 可选 IPC_CREAT | IPC_EXCL
    - 成功返回 shmid；失败 -1（errno：ENOENT/ EEXIST/ EACCES 等）

- 附加到进程地址空间
  - void* shmat(int shmid, const void* shmaddr, int shmflg);
    - shmaddr 一般传 NULL 让内核选择地址；shmflg 可用 SHM_RDONLY 只读附加
    - 成功返回地址；失败返回 (void*)-1

- 撤销（从进程分离）
  - int shmdt(const void* shmaddr);
    - 进程侧“解绑”映射；对象仍可存在

- 控制/删除
  - int shmctl(int shmid, int cmd, struct shmid_ds* buf);
    - 删除对象：cmd = IPC_RMID（注意不是“SHM_UNLINK”）
    - 查询/设置元数据：IPC_STAT/IPC_SET；lock/unlock：SHM_LOCK/SHM_UNLOCK（特权）

- 诊断
  - ipcs -m 查看当前共享内存段；ipcrm -M <key> 或 ipcrm -m <shmid> 删除

---

### 典型流程与要点

1) 选定路径并生成 key（ftok）
   - 路径文件应稳定存在（如 /tmp/your_app_shm_key）；删除/替换文件会改变 inode → 可能改变 key。

2) shmget 创建/打开段
   - 创建者：shmget(key, size, IPC_CREAT|0666)
   - 仅打开：shmget(key, 0 或 size, 0666)（若不存在将 ENOENT）

3) shmat 映射后即可读写
   - 返回指针可直接作为共享缓冲操作；无边界/无同步保证

4) shmdt 撤销映射
   - 每个附加的进程结束使用时都应 shmdt

5) shmctl(IPC_RMID) 标记删除
   - 段被标记删除后，新的 shmget 将失败；仅当最后一个进程 shmdt 后内核真正释放

- 与管道对比
  - 管道：流式、一读即消费；共享内存：可随机访问、可多次读取、需自管同步与生命周期
- 同步建议
  - 使用进程间互斥/条件变量（pthread_mutexattr_setpshared）、POSIX 信号量（sem_open）、或基于管道/eventfd 的事件通知
- 权限与安全
  - 通过 shmflg 的权限位（类似文件权限）；注意 umask 影响
- 资源限额
  - shmmax/shmall 等内核参数限制段大小与总页数（/proc/sys/kernel/shmmax 等）

---

### 最小可运行示例

- 注意：为简洁演示，示例未加入同步原语；真实应用请加锁与“已写长度/序号”等元数据。

```c name=sysv_shm_writer.c
##define _POSIX_C_SOURCE 200809L
##include <sys/ipc.h>
##include <sys/shm.h>
##include <sys/types.h>
##include <stdio.h>
##include <string.h>
##include <errno.h>
##include <stdlib.h>
##include <unistd.h>

static const char* KEY_PATH = "/tmp/sysv_shm_demo.key"; // 确保文件存在：touch /tmp/sysv_shm_demo.key
static const int   PROJ_ID  = 65;                       // 'A'
static const size_t SZ      = 4096;

int main(void) {
    // 确保 key 文件存在
    FILE* f = fopen(KEY_PATH, "a"); if (f) fclose(f);

    key_t key = ftok(KEY_PATH, PROJ_ID);
    if (key == (key_t)-1) { perror("ftok"); return 1; }

    int shmid = shmget(key, SZ, IPC_CREAT | 0666);
    if (shmid == -1) { perror("shmget"); return 1; }

    void* p = shmat(shmid, NULL, 0);
    if (p == (void*)-1) { perror("shmat"); return 1; }

    const char* msg = "hello from writer (System V shm)";
    memcpy(p, msg, strlen(msg) + 1);

    printf("writer: wrote message, shmid=%d\n", shmid);
    printf("observe with: ipcs -m | grep %d\n", shmid);

    // 演示保持附加一段时间，便于 reader 运行与观察 nattch
    sleep(5);

    // 撤销映射
    if (shmdt(p) == -1) perror("shmdt");

    // 可选：由“拥有者”进程决定是否标记删除（IPC_RMID）
    // 若你希望段在所有进程退出后自动消失，可在此调用 IPC_RMID
    if (shmctl(shmid, IPC_RMID, NULL) == -1) perror("shmctl IPC_RMID");

    return 0;
}
```

```c name=sysv_shm_reader.c
##define _POSIX_C_SOURCE 200809L
##include <sys/ipc.h>
##include <sys/shm.h>
##include <sys/types.h>
##include <stdio.h>
##include <string.h>
##include <errno.h>
##include <stdlib.h>
##include <unistd.h>

static const char* KEY_PATH = "/tmp/sysv_shm_demo.key";
static const int   PROJ_ID  = 65;

int main(void) {
    key_t key = ftok(KEY_PATH, PROJ_ID);
    if (key == (key_t)-1) { perror("ftok"); return 1; }

    // 若 writer 尚未创建，会 ENOENT
    int shmid = shmget(key, 0, 0666);
    if (shmid == -1) { perror("shmget (reader)"); return 1; }

    const char* p = (const char*)shmat(shmid, NULL, SHM_RDONLY);
    if (p == (void*)-1) { perror("shmat (reader)"); return 1; }

    printf("reader: \"%s\"\n", p);

    if (shmdt(p) == -1) perror("shmdt (reader)");

    // 注意：reader 通常不负责 IPC_RMID，以免影响其他进程
    return 0;
}
```

```c name=sysv_shm_cleanup.c
##define _POSIX_C_SOURCE 200809L
##include <sys/ipc.h>
##include <sys/shm.h>
##include <sys/types.h>
##include <stdio.h>

static const char* KEY_PATH = "/tmp/sysv_shm_demo.key";
static const int   PROJ_ID  = 65;

int main(void) {
    key_t key = ftok(KEY_PATH, PROJ_ID);
    if (key == (key_t)-1) { perror("ftok"); return 1; }

    int shmid = shmget(key, 0, 0666);
    if (shmid == -1) { perror("shmget"); return 1; }

    if (shmctl(shmid, IPC_RMID, NULL) == -1) { perror("shmctl IPC_RMID"); return 1; }
    puts("Marked shm for removal (IPC_RMID). It will be freed after last detach.");
    return 0;
}
```

- 编译与运行
  ```bash
  gcc -Wall -Wextra -O2 -std=c11 -o shm_writer  sysv_shm_writer.c
  gcc -Wall -Wextra -O2 -std=c11 -o shm_reader  sysv_shm_reader.c
  gcc -Wall -Wextra -O2 -std=c11 -o shm_cleanup sysv_shm_cleanup.c

  ## 终端1
  ./shm_writer
  ## 终端2（writer 睡眠期间执行）
  ./shm_reader

  ## 观察
  ipcs -m
  ipcs -m | grep <shmid>
  ## 清理（如需要）
  ./shm_cleanup
  ```

---

### 常见坑与排查

- “删除”与“撤销”的区别
  - shmdt：仅当前进程解除映射，段仍可能存在
  - shmctl(shmid, IPC_RMID, NULL)：标记删除；最后一个进程 detach 后真正释放
- 误用命令名
  - System V 共享内存删除应使用 IPC_RMID，而非 “SHM_UNLINK”（那是 POSIX shm 的命名）
- ftok 生成 key 失败
  - 路径不存在/不可访问；或容器/不同挂载环境 inode 改变导致 key 不一致
- shmget ENOENT/EEXIST
  - ENOENT：未创建；EEXIST：带 IPC_EXCL 重复创建
- 权限/umask
  - shmflg 的权限位与 umask 共同决定可访问性；开发期建议 0666 简化测试
- 大小与内核限额
  - 超过 shmmax/shmall 会失败；在 Linux 可通过 /proc/sys/kernel/shmmax 等调整
- 同步缺失导致“脏读/读未初始化”
  - 引入简单头部（长度/序列/校验）+ 互斥/条件变量/信号量，或使用 eventfd/管道做通知
- 资源泄漏
  - 进程异常退出未调用 IPC_RMID → 段残留；使用 ipcrm 工具或在“守护/服务”中集中清理

---

### 小结
- System V 共享内存在同主机多进程间提供高性能共享区域，使用五步法：ftok → shmget → shmat → 读写 → shmdt/IPC_RMID。
- 它不提供同步/消息语义，需自定义协议与并发控制；生命周期管理尤为关键（撤销 vs 删除）。
- 如需更现代与简洁的接口，可考虑 POSIX 共享内存（shm_open + mmap）或直接使用 mmap 匿名/文件映射配合进程间同步原语。



## 九、信号机制（Linux Signals）

### 摘要
- 信号是 Linux 中一种软件层面的中断机制，用于在进程之间或内核到进程间传递事件与指令。
- 常见信号包括 SIGHUP、SIGINT、SIGQUIT、SIGILL、SIGSEGV、SIGPIPE、SIGTERM、SIGSTOP、SIGTSTP、SIGCONT、SIGALRM、SIGCHLD 等。
- 信号来源多样：键盘按键、系统调用、硬件异常、命令行工具、软件运行条件（如除零、非法内存访问）等。
- 进程对信号的响应方式：采用默认动作、忽略、捕捉（注册处理函数改变默认行为）。
- 常用命令：kill/killall/pkill 发送与管理信号；kill -l 列出信号；常见如 kill -9(SIGKILL) 强制终止、kill -15(SIGTERM) 请求终止等。
- 子进程状态变化（如退出）会向父进程发送 SIGCHLD，父进程可据此回收子进程资源。

- 段错误产生的原因（15:54）

### 核心概念与响应方式
- 默认动作：大多为终止；部分为忽略或停止；也可能生成 core dump。
- 忽略：进程可选择忽略多数信号（如 SIGTERM），但并非全部。
- 捕捉：通过注册处理函数（signal/sigaction）自定义处理逻辑与清理流程。
- 无法捕捉/忽略的信号：SIGKILL、SIGSTOP。其余多数信号可被捕捉或忽略。

### 常用信号速览
- SIGHUP：挂起（终端关闭、控制终端断开）；常用于“让守护进程重新加载配置”。
- SIGINT：中断（Ctrl+C）；礼貌地让前台程序退出。
- SIGQUIT：退出并可能产生 core（Ctrl+\）。
- SIGILL：非法指令。
- SIGSEGV：段错误（非法内存访问）。
- SIGPIPE：写无读端管道。
- SIGTERM：请求终止（推荐优先使用，给程序清理机会）。
- SIGKILL：强制终止（不可拦截、不可忽略、不可处理）。
- SIGSTOP：内核层暂停（不可拦截/忽略）。
- SIGTSTP：用户暂停（Ctrl+Z，可被处理）。
- SIGCONT：继续运行（可唤醒 STOP/TSTP 暂停的进程）。
- SIGALRM：定时器到期（alarm/setitimer）。
- SIGCHLD：子进程状态变化（退出、停止、继续）。

### 命令与示例
- 列出信号：`kill -l`
- 按编号发送（编号因架构可能不同，以常见 x86_64 为例）：
  - `kill -2 <PID>` → SIGINT
  - `kill -9 <PID>` → SIGKILL
  - `kill -15 <PID>` → SIGTERM
  - `kill -18 <PID>` → SIGCONT
  - `kill -19 <PID>` → SIGSTOP
  - `kill -20 <PID>` → SIGTSTP
- 按名称发送（推荐更清晰）：`kill -SIGTERM <PID>`、`kill -SIGKILL <PID>`
- 通过进程名：`pkill -SIGTERM <name>`、`killall -9 <name>`

### 示例要点
- 关闭终端导致前台进程收到 SIGHUP 并终止；守护进程通常已与控制终端脱离，不受影响。
- 段错误演示：向非法地址解引用写入会触发 SIGSEGV。
- 管道写端无读者时触发 SIGPIPE；可通过忽略 SIGPIPE 并检查写入返回值来改用错误处理路径。
- 通过 `sigaction` 注册处理函数可实现捕捉与屏蔽（设置信号屏蔽字）等高级控制。

### 更正与说明
- 信号名称：应为 SIGHUP（非 “SIGHUB”）。
- 不可捕捉/忽略：SIGKILL 与 SIGSTOP；SIGTERM 可以被捕捉或忽略。
- 信号编号：不同体系结构编号可能不同。上文编号以常见 x86_64 Linux 为例（如 18→SIGCONT，19→SIGSTOP，20→SIGTSTP）。在目标系统上请以 `kill -l` 为准。



## 十、信号：编程发送与定时器（Programming Signals & Timers）

### 摘要
- 通过编程发送信号的方式包括 kill 和 raise 等 API；kill 的 pid 参数支持“单进程/本进程组/指定进程组/所有进程”多种语义。
- 定时器常用 API：alarm（秒级一次性/覆盖型）、ualarm（微秒级、可周期）、setitimer（更灵活的间隔定时器，支持 ITIMER_REAL/ITIMER_VIRTUAL/ITIMER_PROF）。
- 将“信号捕捉（signal/sigaction）”与定时器信号组合，可实现“定时回调”而非直接终止程序。
- pause 可用于“睡眠直至信号到达”，配合定时器实现简易阻塞等待。


### 信号编程：发送 API
- kill
  - 原型：int kill(pid_t pid, int sig);
  - 语义：
    - pid > 0：发给该 PID 的单个进程
    - pid == 0：发给“与调用者同一进程组”的所有进程
    - pid < -1：发给“进程组 ID 为 -pid”的所有进程
    - pid == -1：发给“调用者有权限发送信号的所有进程”（危险！root 下可能导致系统大范围中断/退出）
- raise
  - 原型：int raise(int sig);
  - 等价于：kill(getpid(), sig)

示例（发送 SIGSEGV 仅为演示，不建议在生产使用这种方式中止程序）:
```c
#include <signal.h>
#include <unistd.h>

int main(void) {
  pid_t me = getpid();
  kill(me, SIGSEGV);  // 向自身发送段错误信号
  return 0;
}
```

### 定时器 API
- alarm
  - 原型：unsigned int alarm(unsigned int seconds);
  - 设置 seconds 秒后触发 SIGALRM；再次调用会覆盖前一个 alarm，返回剩余秒数。
  - 典型用途：简单一次性定时；配合信号处理器实现“到时回调”。
- ualarm
  - 原型：useconds_t ualarm(useconds_t usecs, useconds_t interval);
  - usecs 为首次触发延迟（微秒），interval 为周期（微秒）；interval 为 0 表示一次性。
- setitimer
  - 原型：int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
  - which：
    - ITIMER_REAL：真实时间（wall-clock），触发 SIGALRM
    - ITIMER_VIRTUAL：进程用户态 CPU 时间，触发 SIGVTALRM
    - ITIMER_PROF：进程总 CPU 时间（用户态+内核态），触发 SIGPROF
  - struct itimerval:
    - it_value：首次触发时间（timeval：秒+微秒）
    - it_interval：周期（为 0 则一次性）

示例：alarm + pause（阻塞直至信号）
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void on_alarm(int sig) {
  (void)sig;
  write(STDOUT_FILENO, "alarm fired\n", 12); // async-signal-safe 输出
}

int main(void) {
  signal(SIGALRM, on_alarm); // 演示用；生产建议 sigaction
  alarm(3);                  // 3 秒后触发 SIGALRM
  pause();                   // 阻塞直到任一信号到达并被处理
  return 0;
}
```

示例：ualarm 循环定时（微秒级）
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

void on_alarm(int sig) {
  (void)sig;
  write(STDOUT_FILENO, "tick\n", 5);
}

int main(void) {
  struct sigaction sa = {0};
  sa.sa_handler = on_alarm;
  sigaction(SIGALRM, &sa, NULL);

  // 500ms 后首次触发，之后每 500ms 触发一次
  ualarm(500000, 500000);

  // 简单主循环：工作 + 让出 CPU
  for (;;) {
    pause(); // 被 SIGALRM 唤醒
  }
}
```

示例：setitimer 周期定时（秒+微秒）
```c
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>

void on_alarm(int sig) {
  (void)sig;
  write(STDOUT_FILENO, "itimer\n", 7);
}

int main(void) {
  struct sigaction sa = {0};
  sa.sa_handler = on_alarm;
  sigaction(SIGALRM, &sa, NULL);

  struct itimerval tv = {0};
  tv.it_value.tv_sec = 1;      // 首次 1 秒后触发
  tv.it_interval.tv_sec = 2;   // 之后每 2 秒触发一次
  setitimer(ITIMER_REAL, &tv, NULL);

  for (;;) pause();
}
```

### 信号捕捉与定时器结合（关键点）
- 使用 sigaction 而非 signal，以获得更可控的语义（如 SA_RESTART、信号屏蔽集等）。
- 处理函数中仅使用 async-signal-safe 的系统调用（如 write、_exit）；避免调用非可重入的库函数（printf、malloc 等）。
- 若需与主循环交换信息，使用 volatile sig_atomic_t 标志位，或更安全的“管道自唤醒”/“eventfd”方案。
- 对可能被中断的系统调用处理 EINTR（或使用 SA_RESTART 自动重启）。

示例：安全更新标志位
```c
#include <signal.h>
#include <unistd.h>
#include <stdatomic.h>
#include <stdio.h>

static volatile sig_atomic_t ticked = 0;

void on_alarm(int sig) {
  (void)sig;
  ticked = 1; // 仅写标志
}

int main(void) {
  struct sigaction sa = {0};
  sa.sa_handler = on_alarm;
  sigaction(SIGALRM, &sa, NULL);

  alarm(1); // 1 秒后触发一次

  for (;;) {
    if (ticked) {
      ticked = 0;
      puts("do periodic job"); // 在主循环中做真正的工作
      break;
    }
    pause(); // 等待信号到来
  }
  return 0;
}
```

### 更正与说明
- 名称澄清
  - 文中“q 函数”应为 kill；“rise 函数”应为 raise；“get PID”应为 getpid；“pass 函数”应为 pause。
- kill 的 pid 规则
  - pid == -1 会向“调用者有权限的所有进程”发送信号；root 下极其危险，请勿在生产环境使用。
  - pid < -1 表示进程组，目标为“进程组 ID 为 -pid 的所有进程”（注意与“同一进程组”pid==0 区分）。
- 定时器与信号类型
  - ITIMER_REAL 触发 SIGALRM；ITIMER_VIRTUAL 触发 SIGVTALRM；ITIMER_PROF 触发 SIGPROF。
- alarm 语义
  - 多次调用 alarm 会覆盖上一次设置；返回值为上一个尚未到期的剩余秒数。
- 生产建议
  - 使用 sigaction 与最小化的处理函数；在主线程中完成复杂逻辑。
  - 对被信号打断的阻塞调用处理 EINTR 或设置 SA_RESTART。

## 十一、信号：使用 signal 捕捉与处理

### 摘要
- signal 用于“改变某个信号的默认行为”，将其绑定到用户自定义的处理函数（handler），从而实现捕捉信号并执行自定义逻辑。
- 捕捉流程：程序运行→信号到达→内核判断处理策略→若用户已注册处理函数则转入用户 handler→返回继续执行。
- signal 的第二个参数是函数指针（新的处理函数），返回值是“旧的处理函数指针”，可用于恢复原有行为（如默认处理）。
- 常见用例：捕捉 Ctrl+C（SIGINT）打印提示并不中止；在合适时机恢复默认行为，实现“优雅退出”。

### 基本用法与函数指针
- 处理函数原型
  - void handler(int sig); // sig 为到达的信号编号
- 注册与恢复
  - sighandler_t prev = signal(SIGINT, handler); // 注册新处理器，保存旧处理器
  - signal(SIGINT, prev); // 恢复旧处理器（如默认处理）

示例：捕捉 SIGINT（Ctrl+C），打印提示但不中止
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

static void on_sigint(int sig) {
  (void)sig;
  // 注意：printf 非 async-signal-safe，仅演示；生产建议使用 write
  printf("Caught SIGINT, press again within 3s to exit...\n");
}

int main(void) {
  // 注册处理器并保存旧的，以便后续恢复
  sighandler_t old = signal(SIGINT, on_sigint);
  if (old == SIG_ERR) {
    perror("signal");
    return 1;
  }

  // 主循环
  for (;;) {
    pause(); // 等待信号唤醒
    // 此处可进行与“被捕捉信号”相关的安全处理
  }
  return 0;
}
```

示例：恢复默认处理，实现“第二次 Ctrl+C 退出”
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

static volatile sig_atomic_t seen = 0;
static sighandler_t old_int = SIG_DFL; // 记录默认或旧处理器

static void on_sigint(int sig) {
  (void)sig;
  if (!seen) {
    seen = 1;
    write(STDOUT_FILENO, "Caught once, press Ctrl+C again to exit.\n", 42);
    // 恢复默认处理器，下一次 SIGINT 将终止进程
    signal(SIGINT, old_int);
  }
}

int main(void) {
  old_int = signal(SIGINT, on_sigint);
  if (old_int == SIG_ERR) {
    perror("signal");
    return 1;
  }
  for (;;) pause();
}
```

### 信号行为选项与语义
- 常量
  - SIG_DFL：恢复默认处理
  - SIG_IGN：忽略该信号
- 不可捕捉/忽略
  - SIGKILL、SIGSTOP
- 常见可捕捉示例
  - SIGINT（Ctrl+C）、SIGHUP（终端挂起）、SIGALRM（定时器）等

### 实战要点与最佳实践
- signal 与 sigaction
  - signal 用于入门演示；生产建议使用 sigaction，具备更明确与可移植语义（支持 sa_mask、SA_RESTART 等）。
- 异步信号安全
  - 处理函数中仅调用 async-signal-safe 函数（如 write、_exit）；避免 printf、malloc、pthread_mutex_lock 等。
  - 与主循环通信建议使用 volatile sig_atomic_t 标志位、管道自唤醒或 eventfd。
- 被中断的系统调用
  - 处理 EINTR；或在 sigaction 中使用 SA_RESTART 自动重启某些被中断的阻塞调用。
- 何时恢复旧处理器
  - 将 signal 的返回值保存到静态或全局变量；在合适时机（通常在主循环上下文）恢复，而非在 handler 内复杂恢复。
- 可移植性
  - 不同系统对 signal 语义可能差异；sigaction 更可靠。

### 更多示例：与定时器结合
- 将定时器信号与捕捉结合，实现“到时回调而非退出”
```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>

static void on_alarm(int sig) {
  (void)sig;
  write(STDOUT_FILENO, "tick\n", 5);
}

int main(void) {
  signal(SIGALRM, on_alarm); // 演示用；生产用 sigaction
  alarm(1);                  // 1 秒后触发一次
  for (;;) pause();          // 每次 SIGALRM 唤醒，on_alarm 执行
}
```

### 更正与说明
- 名称与函数
  - “q 函数”应为 kill；“rise 函数”应为 raise；“get PID”应为 getpid；“pass”应为 pause。
- signal 返回值
  - 返回旧的处理函数指针（sighandler_t），可用于恢复默认行为或先前的处理器。
- 控制台打印
  - 示例中为教学使用 printf；生产中推荐在 handler 里使用 write，并在主线程执行复杂逻辑。
- 推荐替代
  - 建议在生产中使用 sigaction 注册处理器，并合理设置 sa_mask 与 SA_RESTART，提升可控性与健壮性。



## 十二、sigaction、alarm、setitimer 实战整理

### 摘要
本视频讲解了在 C 语言中通过信号处理机制实现定时器的思路与实践。内容涵盖：
- 使用 signal 与更推荐的 sigaction 完成信号捕捉与处理。
- 使用 alarm 实现“单次触发后在处理函数中重设”的周期性定时效果。
- 使用 setitimer 配合结构体设定“启动延迟 + 周期触发”的定时器。
- 示例展示如何捕捉 Ctrl+C（SIGINT）以及 SIGALRM，并通过结构体配置与回调函数完成简单定时器程序。

### 重点
- 信号捕捉的全过程（用户态 -> 内核态 -> do_signal -> 处理函数 -> 返回用户态）
- sigaction 的优势与推荐使用理由（跨 Unix 版本行为更一致）
- 定时器的两种实现方法：alarm 与 setitimer

### 核心概念与流程
- 信号发生时，用户程序被中断，内核调用 do_signal，若用户注册了处理函数，完成回调后再返回用户态继续执行。
- 捕捉信号两步走：
  1) 定义自定义信号处理函数
  2) 将处理函数与目标信号关联（推荐使用 sigaction）
- 推荐用 sigaction 替代 signal 的原因：不同 Unix 版本中 signal 行为可能存在差异，sigaction 更加一致与可控。
- struct sigaction 常用成员：
  - sa_handler：简单处理函数指针
  - sa_mask：执行处理函数期间屏蔽的信号集（常用 sigemptyset 清空）
  - sa_flags：行为标志；若使用 sa_sigaction 需设置对应标志，否则默认用 sa_handler

### API 概览与对比
- signal(int signum, sighandler_t handler)
  - 使用简单，但跨平台行为可能不一致
- sigaction(int signum, const struct sigaction* act, struct sigaction* oldact)
  - 更一致、可配置；通过 act 指定新的行为，oldact 可取回旧行为
- alarm(unsigned int seconds)
  - 设定 seconds 秒后向进程发送 SIGALRM；默认仅触发一次
- setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value)
  - 支持启动延迟（it_value）与周期（it_interval）：
    - it_value：首次触发延迟
    - it_interval：后续周期
  - 常用 which：ITIMER_REAL（向进程发送 SIGALRM）


### 示例要点与实践建议
- 使用 sigaction 捕捉 SIGINT（Ctrl+C）与 SIGALRM：
  - 使用 sigemptyset(&act.sa_mask) 清空屏蔽集合
  - act.sa_flags 通常置 0（默认采用 sa_handler）
  - 仅捕捉需要的信号，避免干扰
- 使用 alarm 实现“每秒触发”：
  - alarm(1) 默认只触发一次
  - 在 SIGALRM 处理函数末尾再次调用 alarm(1)，实现周期性触发
- 使用 setitimer 实现“启动延迟 + 周期触发”：
  - struct itimerval it;
    - it.it_value：首次触发延迟（例如 5 秒）
    - it.it_interval：周期（例如 1 秒）
  - setitimer(ITIMER_REAL, &it, NULL) 后，5 秒后首次触发，随后每 1 秒触发一次
- 注意事项
  - 某些系统中 sleep 可能依赖 SIGALRM，可能与自设定时器冲突；需要时可注释或避免混用
  - 未安装 SIGALRM 处理函数时，默认行为可能终止程序；务必先设置处理函数
  - 通过 sigaction 获取/恢复旧行为时，第三个参数可用于保存 oldact

### 伪代码片段（思路示例）
```c
// 1) 安装 SIGINT、SIGALRM 处理器（推荐使用 sigaction）
struct sigaction act;
act.sa_handler = handler;          // 简单处理函数
sigemptyset(&act.sa_mask);
act.sa_flags = 0;                  // 使用 sa_handler
sigaction(SIGINT,  &act, NULL);    // 捕捉 Ctrl+C
sigaction(SIGALRM, &act, NULL);    // 捕捉定时器信号

// 2) 使用 alarm 实现周期性触发（在 handler 中重设 alarm）
alarm(1); // 首次 1 秒后触发

void handler(int sig) {
  if (sig == SIGINT) {
    // 处理 Ctrl+C
  } else if (sig == SIGALRM) {
    // 执行定时任务
    alarm(1); // 继续下一次触发
  }
}
```

```c
// 使用 setitimer 实现“延迟 + 周期”
// 5 秒后首次触发，之后每 1 秒触发一次
struct sigaction act;
act.sa_handler = handler;
sigemptyset(&act.sa_mask);
act.sa_flags = 0;
sigaction(SIGALRM, &act, NULL);

struct itimerval it = {0};
it.it_value.tv_sec = 5;      // 首次触发延迟 5s
it.it_value.tv_usec = 0;
it.it_interval.tv_sec = 1;   // 周期 1s
it.it_interval.tv_usec = 0;

setitimer(ITIMER_REAL, &it, NULL);
```

### 小结
- sigaction 相较 signal 更稳定、可控，推荐作为信号处理首选 API。
- alarm 适合简单、轻量的周期触发（需在处理器中重置）。
- setitimer 适合需要“启动延迟 + 固定周期”的定时器场景。
- 正确配置 struct sigaction 的 sa_handler、sa_mask、sa_flags，并在使用 setitimer 时正确设置 it_value 与 it_interval，可实现可靠的定时器程序。


## 十三、信号与子进程回收：SIGCHLD + sigaction 实战整理

### 摘要
本视频讲解了如何利用信号机制（SIGCHLD）配合 wait 系列函数实现子进程的异步回收。先回顾 sigaction 的作用与上节课定时器示例，再引出 SIGCHLD 的触发条件、发送者与接收者。核心思想是：捕捉到 SIGCHLD 后在处理函数中执行回收，避免父进程在 wait 上阻塞，可继续并发处理自身任务。视频最后通过代码示例展示父进程在不停执行自身逻辑的同时，异步回收已退出的子进程。

### 重点
- 信号捕捉应用场景：利用 SIGCHLD 回收子进程，避免父进程在 wait 上阻塞
- SIGCHLD 与 wait 的协作方式：信号到来再回收，实现异步
- sigaction 的稳定性与可配置性：推荐用 sigaction 而非 signal
完成过定时器示例

### 核心概念
- SIGCHLD 的触发与流向
  - 触发条件：子进程状态改变（终止、被停止、从停止态恢复运行等）
  - 发送者：子进程
  - 接收者：其父进程
- 为什么用信号配合回收而不是直接 wait
  - wait 默认阻塞，父进程会停在 wait 上无法并行做其他事
  - 捕捉 SIGCHLD 后再回收，父进程主循环不阻塞，提升并发能力与响应性
- sigaction 相对 signal 的优势
  - 跨 Unix 版本行为更一致
  - 支持更丰富的控制（sa_mask、sa_flags、sa_sigaction 等）

### API 与用法要点
- sigaction(int signum, const struct sigaction* act, struct sigaction* oldact)
  - 常用成员：
    - sa_handler 或 sa_sigaction：信号处理函数指针
    - sa_mask：处理期间屏蔽的信号集（常用 sigemptyset 清空）
    - sa_flags：行为标志（如 SA_RESTART、SA_NOCLDSTOP、SA_NOCLDWAIT 等）
- wait / waitpid
  - wait 阻塞；waitpid 可配合 WNOHANG 非阻塞检查
  - 建议在处理函数里用 waitpid(-1, &status, WNOHANG) 循环回收所有已退出子进程

### 示例思路（伪代码）
```c
// 1) 安装 SIGCHLD 处理器（推荐用 sigaction）
static void on_sigchld(int sig) {
  int saved = errno;        // 保护 errno
  int status;
  pid_t pid;
  // 循环回收，避免遗漏多个同时退出的子进程
  while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
    // 可在此打印/记录 pid、退出码等
  }
  errno = saved;
}

int main(void) {
  struct sigaction act = {0};
  act.sa_handler = on_sigchld;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0; // 可按需设置 SA_RESTART / SA_NOCLDSTOP 等
  sigaction(SIGCHLD, &act, NULL);

  pid_t pid = fork();
  if (pid == 0) {
    // 子进程：模拟工作后退出
    sleep(5);
    _exit(0);
  } else if (pid > 0) {
    // 父进程：主循环不阻塞在 wait，上层逻辑持续运行
    for (;;) {
      printf("father process is working...\n");
      sleep(1);
    }
  } else {
    perror("fork");
    return 1;
  }
}
```

### 实践要点与注意事项
- 处理函数中应使用循环 waitpid(-1, &status, WNOHANG) 回收所有已退出子进程，避免产生僵尸进程
- 处理函数要短小可重入，避免调用不安全的库函数；必要时只做标记，实际回收放到主循环检查
- 可根据需求设置 sa_flags：
  - SA_RESTART：在某些系统调用被信号中断后自动重启
  - SA_NOCLDSTOP：子进程停止/继续时不发送 SIGCHLD
  - SA_NOCLDWAIT：不留下僵尸（内核自动回收），父进程也不会收到 SIGCHLD
- 若仅用 wait（阻塞），父进程将无法并发处理其他任务；使用 SIGCHLD 可避免此问题
- 多子进程场景下，建议结构化管理子进程 PID 与状态，结合信号与非阻塞回收保障健壮性

### 小结
- SIGCHLD 在子进程状态改变时由子进程发送给父进程，是实现“异步回收”的关键
- 使用 sigaction 捕捉 SIGCHLD，并在处理函数中用 waitpid(WNOHANG) 循环回收，能避免父进程阻塞
- 相较直接 wait，基于信号的回收方式更灵活，能保证父进程持续执行自身业务逻辑



## 十四、信号进阶：信号集、阻塞（屏蔽）与 sigprocmask

### 摘要
本节介绍信号的进阶主题：信号集与信号阻塞（屏蔽）。在回顾信号三种处理方式（默认、忽略、捕捉）及其“软中断”特性后，重点说明为何需要阻塞信号（例如访问关键资源时避免被打断），并引入信号的两种状态：抵达（deliver）与未决/挂起（pending）。通过对信号集的操作与 sigprocmask 的使用，实现“先阻塞，后按需解阻塞并延迟处理”的效果，配合示例展示程序如何正确捕捉、暂缓与再次接收信号。

### 重点
- 信号的应用场景：定时器、不阻塞父进程的子进程回收等
- 信号阻塞与解阻塞的实现方法（sigset_t 操作 + sigprocmask）
- 信号的两种状态：抵达（deliver）与未决（pending）
- 信号集的操作函数：sigemptyset/sigfillset/sigaddset/sigdelset/sigismember
- 信号屏蔽的作用：在关键时段避免被信号打断，同时保留信号以便稍后处理

### 核心概念
- 信号是软中断：到来时会打断用户态程序，转入内核处理，再返回用户态
- 三种处理方式
  - 默认处理：按系统默认动作执行
  - 忽略：仍经历中断流程，但程序不做额外处理
  - 捕捉：跳转到用户定义的处理函数执行
- 为什么需要阻塞
  - 某些关键区段不希望被信号打断（如访问重要资源、执行原子性逻辑）
  - 既不想丢弃信号，又不想立即处理，可先阻塞，待时机合适再解阻塞
- 信号两种状态
  - 抵达（deliver）：信号已到达并根据处理方式执行（默认/忽略/捕捉）
  - 未决（pending/挂起）：因被阻塞暂存起来，待解阻塞后再行处理

### 进程中的信号相关数据结构（抽象）
- 未决信号集（pending set）：只读反映已到达但尚未处理（因阻塞）的信号
- 信号屏蔽字（blocked set）：可写，用比特图指示哪些信号被阻塞（屏蔽）
- 每一位对应一个具体信号；设置/清除相应位以阻塞/放行该信号

### API 与操作
- 信号集类型
  - sigset_t：信号集类型（内部为比特图）
- 信号集操作
  - sigemptyset(sigset_t* set)：清空（全部不阻塞/不包含）
  - sigfillset(sigset_t* set)：置满（包含所有信号）
  - sigaddset(sigset_t* set, int signum)：向集合添加一个信号
  - sigdelset(sigset_t* set, int signum)：从集合删除一个信号
  - sigismember(const sigset_t* set, int signum)：判断是否在集合中
- 屏蔽与解屏蔽（关键）
  - sigprocmask(int how, const sigset_t* set, sigset_t* oldset)
    - how:
      - SIG_BLOCK：将 set 中的信号加入屏蔽字（阻塞这些信号）
      - SIG_UNBLOCK：从屏蔽字移除 set 中的信号（解阻塞）
      - SIG_SETMASK：屏蔽字整体替换为 set
    - oldset：可选，用于取回调用前的屏蔽字
- 配合 sigaction 捕捉信号
  - 推荐使用 sigaction 安装处理器（sa_handler/sa_sigaction、sa_mask、sa_flags）
  - sa_mask 可指定处理函数执行期间要额外屏蔽的信号

### 示例思路（阻塞与延迟处理 SIGINT）
1) 安装 SIGINT 处理器（打印收到的信号）
2) 构造一个信号集，将 SIGINT 加入集合
3) 调用 sigprocmask(SIG_BLOCK, &set, ...) 阻塞 SIGINT
4) 在阻塞期间按下 Ctrl+C 不会立即触发处理器，信号进入未决状态
5) 适当时机调用 sigprocmask(SIG_UNBLOCK, &set, ...) 解阻塞
6) 未决的 SIGINT 立即被投递，处理函数被调用

```c
// 安装处理器（省略错误检查）
static void handler(int sig) {
  printf("got sig = %d\n", sig);
}

int main(void) {
  struct sigaction act = {0};
  act.sa_handler = handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
  sigaction(SIGINT, &act, NULL); // 捕捉 Ctrl+C

  sigset_t set;
  sigemptyset(&set);
  sigaddset(&set, SIGINT);

  // 1) 阻塞 SIGINT
  sigprocmask(SIG_BLOCK, &set, NULL);

  // 关键区段：此时按下 Ctrl+C 不会立即触发处理器（进入未决）
  sleep(5);

  // 2) 解阻塞 SIGINT：未决信号立即被投递，调用 handler
  sigprocmask(SIG_UNBLOCK, &set, NULL);

  // 主循环
  for (;;) {
    // 其他工作...
    sleep(1);
  }
}
```

### 实践要点与注意事项
- 阻塞并不等于丢弃：解阻塞后，未决信号会被立即投递
- 处理函数应尽量简短且只调用异步信号安全（async-signal-safe）的函数
- 可能需要 SA_RESTART 以自动重启被信号中断的系统调用
- 多线程程序应使用 pthread_sigmask 而非 sigprocmask 控制线程级屏蔽
- 与定时器（SIGALRM）等信号协同时，注意避免与 sleep 等依赖信号的 API 产生冲突


### 小结
- 通过“信号集 + sigprocmask”可以在关键时段屏蔽特定信号，避免打断，同时保留其为未决态以便稍后处理
- 与 sigaction 配合，可实现安全、可控的信号捕捉与延迟处理
- 掌握信号状态、屏蔽字与常用 API 是编写健壮 UNIX/Linux 信号驱动程序的基础



## 十五、信号驱动程序：pause、sigsuspend 与屏蔽配合

### 摘要
本节在“信号阻塞与信号集”的基础上，引入信号驱动程序设计。围绕 pause 与 sigsuspend 的语义与差异，说明如何在不忙等的前提下，让程序“等待信号到来即执行任务”，并解决“解屏蔽与挂起之间的竞态导致信号丢失”的问题。通过将 sigprocmask 的屏蔽控制与 sigsuspend 的原子替换相结合，可实现可靠的信号驱动任务循环；同时示例了在任务执行期间屏蔽相关信号，避免被打断，以及在任务结束后再解屏蔽并继续等待。

### 重点
- 信号阻塞的概念与未决（pending）状态：延迟处理但不丢弃
- 进程中的两个比特图集合：未决信号集与屏蔽字；sigset_t 为其抽象
- 信号集操作函数：sigemptyset/sigfillset/sigaddset/sigdelset/sigismember
- sigprocmask 用于真正屏蔽/解屏蔽信号
- pause 的语义与局限：可能与解屏蔽存在竞态，导致信号“漏掉”
- sigsuspend 的优势：原子地替换屏蔽字并挂起，避免竞态丢信号
- 信号驱动任务：信号到来执行任务；任务期间屏蔽相关信号防打断

### 核心概念回顾
- 信号三种处理方式：忽略、默认动作、捕捉（回调）
- 两种状态
  - 抵达（deliver）：信号被投递后按配置处理
  - 未决（pending/挂起/味觉）：因被屏蔽暂存，解屏蔽后再处理
- 进程控制块抽象
  - 未决信号集（只读）：哪些信号已到达但尚未处理
  - 信号屏蔽字（可写）：哪些信号当前被阻塞
- 信号集 sigset_t：内部为比特图，每位代表一个信号

### API 与行为
- sigprocmask(int how, const sigset_t* set, sigset_t* oldset)
  - how:
    - SIG_BLOCK：将 set 中信号加入屏蔽字
    - SIG_UNBLOCK：从屏蔽字移除 set 中信号
    - SIG_SETMASK：直接替换为 set
- pause(void)
  - 将进程挂起，直到“一个未被屏蔽并会中断进程的信号”到达
  - 被信号中断且处理函数返回后，pause 返回 -1 并置 errno=EINTR
  - 若信号默认动作为终止，则进程终止；若默认忽略，进程继续挂起
  - 若信号被屏蔽，则无法唤醒
  - 与“先解屏蔽再 pause”之间存在竞态：信号可能在两步之间到达并被消化，导致 pause 永久挂起（信号看似丢失）
- sigsuspend(const sigset_t* mask)
  - 原子操作：暂时将进程的屏蔽字替换为 mask，并挂起等待信号
  - 当一个未被屏蔽的信号到达并处理后，sigsuspend 返回 -1，errno=EINTR，并自动恢复原屏蔽字
  - 避免“解屏蔽和挂起”之间的竞态，是编写可靠信号等待循环的推荐方式

### 信号驱动模式对比
- 基于 pause 的简单模式（存在竞态）
  1) 可选：安装捕捉处理器
  2) 主循环中调用 pause 挂起，收到信号后执行任务
  3) 若在“解屏蔽→pause”之间到达信号，可能被内核立即处理，从而 pause 看不到该信号
- 基于 sigsuspend 的可靠模式（避免竞态）
  1) 用 sigprocmask 先阻塞目标触发信号（防止初始竞态）
  2) 准备一个“解开的临时掩码”（通常为 oldmask 去掉要等待的信号）
  3) 调用 sigsuspend(临时掩码)：原子地“解屏蔽并挂起”，保证中间到达的信号不会丢
  4) 信号处理函数返回后，sigsuspend 返回，原屏蔽字恢复，进入任务执行阶段
  5) 任务执行期间再次阻塞相关信号，防止打断；任务完成后再回到步骤 3

### 示例一：基于 pause 的信号驱动（演示语义与局限）
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdatomic.h>

static volatile sig_atomic_t task_flag = 0;

static void on_sigint(int sig) {
  (void)sig;
  task_flag = 1; // 仅置标志，保持处理器短小可重入
}

static void task(void) {
  printf("task start\n");
  sleep(3);
  printf("task end\n");
}

int main(void) {
  struct sigaction act = {0};
  act.sa_handler = on_sigint;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0; // 可按需 SA_RESTART
  sigaction(SIGINT, &act, NULL);

  for (;;) {
    pause(); // 等待信号：可能遇到“解屏蔽→pause”竞态而丢信号
    if (task_flag) {
      task_flag = 0;
      task();
    }
  }
}
```
说明：简单直观，但若程序在“解屏蔽后到 pause 之前”的极短时隙收到信号，该信号已被内核处理，pause 将继续挂起，造成“看似丢信号”的现象。

### 示例二：基于 sigsuspend 的可靠信号驱动循环（推荐）
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <stdatomic.h>

static volatile sig_atomic_t task_flag = 0;

static void on_sigint(int sig) {
  (void)sig;
  task_flag = 1;
}

static void task(void) {
  printf("task start\n");
  sleep(3);
  printf("task end\n");
}

int main(void) {
  // 1) 安装处理器
  struct sigaction act = {0};
  act.sa_handler = on_sigint;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
  sigaction(SIGINT, &act, NULL);

  // 2) 先阻塞 SIGINT，避免初始竞态
  sigset_t block_set, oldmask;
  sigemptyset(&block_set);
  sigaddset(&block_set, SIGINT);
  sigprocmask(SIG_BLOCK, &block_set, &oldmask);

  for (;;) {
    // 3) 在任务外等待信号：临时掩码 = oldmask 去掉 SIGINT（即允许 SIGINT）
    sigset_t waitmask = oldmask;
    sigdelset(&waitmask, SIGINT);

    while (!task_flag) {
      // 原子：用 waitmask 替换屏蔽字并挂起，返回后自动恢复为 oldmask
      if (sigsuspend(&waitmask) == -1 && errno == EINTR) {
        // 被信号中断，继续检查标志
      }
    }

    // 4) 任务执行期间阻塞 SIGINT，避免打断
    sigprocmask(SIG_BLOCK, &block_set, NULL);
    task_flag = 0;
    task();

    // 5) 任务完成后保持当前 oldmask 基线（SIGINT 仍在 block_set 中）
    // 下轮循环将再次用 sigsuspend 原子等待 SIGINT
  }

  return 0;
}
```
要点：
- 初始先 SIG_BLOCK 住触发信号，避免“冷启动竞态”
- sigsuspend 用 waitmask 原子地“解 SIGINT + 挂起”，不会丢中间到达的信号
- 任务期间再阻塞 SIGINT，确保不中断；任务后回到等待

### 多信号与防打断
- 可将多个触发信号（如 SIGINT、SIGHUP）加入 block_set，并在 waitmask 中逐一解开需要唤醒的信号
- 若希望任务期间完全不被这些信号打断，保持它们在屏蔽字中；任务结束后再回到 sigsuspend 等待
- 若需要“队列化多次触发”，需在处理器中仅设置计数或标志，主循环重复消费，避免在处理器中直接做重活

### 实践要点与注意事项
- 处理函数必须简短且只使用异步信号安全函数；典型做法是仅置标志（sig_atomic_t）
- 关注 EINTR：被信号中断的阻塞系统调用会返回 -1 且 errno=EINTR，可选择重启或在逻辑上处理
- SA_RESTART 可在某些系统调用被中断后自动重启，但要与业务语义匹配
- 多线程程序应使用 pthread_sigmask 控制线程级屏蔽并在专用线程中 sigwait/sigsuspend
- 与依赖 SIGALRM 的 API（如部分实现的 sleep）协作时，注意信号冲突
- 需要确保信号不会被“默认忽略”而导致 pause/sigsuspend 无法唤醒

### 分段总结
- 00:01 信号阻塞的概念
  - 阻塞=延迟处理；挂起/未决状态
  - 抵达后的处理：忽略/默认/捕捉
- 00:55 进程控制块与信号集
  - 未决集与屏蔽字两个比特图；sigset_t 作为抽象
- 02:16 信号集的操作
  - 清空、置满、添加、删除、判断成员
- 02:52 阻塞与解除
  - sigprocmask 完成真正屏蔽与解屏蔽；示例阻塞 Ctrl+C
- 03:38 信号驱动的需求
  - 信号到来执行任务；未到时可做其他或挂起等待
- 05:07 pause 的使用与行为
  - 被信号中断返回 -1；默认终止/忽略的影响；被屏蔽则无法唤醒
- 06:38 信号驱动程序（pause 版）
  - 简单可行但存在解屏蔽与挂起的竞态
- 11:23 任务驱动程序
  - 循环：执行任务→等待信号；按 Ctrl+C 触发
- 15:48 防止打断
  - 任务前后用 sigprocmask 屏蔽/解屏蔽相关信号
- 24:54 sigsuspend 的使用
  - 原子替换屏蔽字并挂起，抓住“中间到达”的信号，避免丢失

### 小结
- pause 便于理解，但与解屏蔽配合时存在丢信号竞态
- sigsuspend 可原子“解屏蔽+挂起”，是可靠的信号等待原语
- 结合 sigprocmask 的屏蔽控制与“任务期间屏蔽、任务后等待”的模式，可编写健壮的信号驱动程序
- 良好的实践是：处理器仅置标志，主循环用 sigsuspend 等待并在受控屏蔽窗口内执行任务



## 十六、System V 消息队列：概念、API 与实战要点

### 摘要
消息队列是进程间通信（IPC）的一种手段，基于队列（先进先出）在内核中保存消息，进程通过队列实现数据传递。视频讲解了消息队列的概念、在内核中的链表式实现、典型使用步骤（创建/打开、发送、接收、删除），以及消息格式与接收时的类型匹配规则，帮助你高效地用消息队列完成进程间通信。

### 重点
- 进程间通信方式：System V 消息队列（内核维护的队列）
- 内核实现：以队列（常见为链表）管理消息节点
- 使用步骤：msgget → msgsnd → msgrcv → msgctl(IPC_RMID)
- 消息格式：首成员必须为 long 类型的消息类型（mtype）
- 类型匹配接收：按 msgtyp 的取值控制接收策略（0/正数/负数）
- 阻塞与非阻塞：通过 IPC_NOWAIT 控制

### 核心概念
- 定义：消息队列是内核中的 IPC 对象，按“先入先出”管理消息；同一类型内保持 FIFO，不同类型结合选择性接收时可能打破全局 FIFO。
- 标识：每个队列有唯一的队列 ID（msqid）。创建/打开通常由 key_t（ftok 生成）+ 权限/标志共同决定。
- 数据结构：内核以队列（常为链表）保存消息，发送端入队，接收端出队。
- 头文件与类型
  - 头文件：<sys/ipc.h>, <sys/msg.h>
  - 关键类型：key_t, ssize_t, size_t

### API 概览（System V）
- msgget(key_t key, int msgflg)
  - 创建或打开消息队列；常用标志：IPC_CREAT | IPC_EXCL；权限位如 0666
  - 成功返回 msqid，失败返回 -1
- msgsnd(int msqid, const void* msgp, size_t msgsz, int msgflg)
  - 发送消息；msgsz 不包含首部 long mtype 的字节数
  - 成功返回 0，失败返回 -1（可配合 IPC_NOWAIT 非阻塞）
- msgrcv(int msqid, void* msgp, size_t msgsz, long msgtyp, int msgflg)
  - 接收消息；返回拷入 mtext 的字节数（≥0），失败返回 -1
  - msgtyp 语义：
    - = 0：接收队列中的第一条消息（任意类型）
    - > 0：接收“类型等于 msgtyp”的第一条消息
    - < 0：接收“类型小于等于 |msgtyp| 的最小类型”的第一条消息
- msgctl(int msqid, int cmd, struct msqid_ds* buf)
  - 队列控制；删除队列用 cmd=IPC_RMID

### 消息格式（必须）
```c
// 发送/接收缓冲区必须以 long mtype 开头；mtext 为自定义负载
struct mymsg {
  long mtype;          // 消息类型（>0）
  char mtext[128];     // 自定义数据
};
// 调用 msgsnd/msgrcv 时的长度 msgsz = sizeof(mtext)，不包括 mtype
```

### 使用步骤
1) 创建/打开队列
```c
key_t key = ftok(".", 100);
int msqid = msgget(key, IPC_CREAT | 0666);
```
2) 发送消息
```c
struct mymsg msg = { .mtype = 1 };
strcpy(msg.mtext, "hello type 1");
int rc = msgsnd(msqid, &msg, sizeof(msg.mtext), 0); // 阻塞发送
```
3) 接收消息
```c
struct mymsg msg;
ssize_t n = msgrcv(msqid, &msg, sizeof(msg.mtext), 0, 0); // 任意类型，阻塞接收
// 或仅接收类型=3：msgrcv(msqid, &msg, sizeof(msg.mtext), 3, 0);
// 或接收类型<=3 的最小类型：msgrcv(msqid, &msg, sizeof(msg.mtext), -3, 0);
```
4) 删除队列
```c
msgctl(msqid, IPC_RMID, NULL);
```

### 行为与细节
- FIFO 与类型匹配
  - 不指定类型（msgtyp=0）时，严格 FIFO
  - 指定类型时，只在该类型内部保持 FIFO；相对其他类型，出队顺序可能不同于全局 FIFO
- 阻塞与非阻塞
  - msgsnd/msgrcv 默认阻塞；加 IPC_NOWAIT 则在无法立即完成时返回 -1 并设置 errno（如 EAGAIN）
- 返回值
  - msgsnd：成功为 0
  - msgrcv：成功为拷入的字节数（mtext 长度）
- 错误处理与中断
  - 被信号中断返回 -1 且 errno=EINTR，按需重试
- 权限
  - 用 0666 之类的权限位控制访问；生产环境注意最小权限原则

### 小结
- System V 消息队列为内核维护的队列型 IPC，对同类型消息提供 FIFO 投递与选择性接收能力
- 正确的消息格式（首成员 long mtype）与长度（不含 mtype）是使用成功的关键
- 掌握 msgget/msgsnd/msgrcv/msgctl 的参数、返回值与标志位，可构建稳定可靠的进程间通信


## 十七、进程间同步：信号量（信号灯）概念、PV 操作与 POSIX 有名/无名信号量实战

### 摘要
本节系统介绍了信号量（信号灯）的概念、工作机制与常见操作。信号量以“计数”表示一类有限资源，用于进程/线程间同步，不承载大量数据。核心操作包括初始化、P（申请/占用，-1）与 V（释放/生产，+1）。课程对比了 POSIX 有名与无名信号量，以及 System V 信号量，并通过“共享内存 + 有名信号量”的生产者-消费者示例讲解如何完成跨进程同步与资源互斥，包含初始化、读写协作、以及 Ctrl+C 清理信号量（sem_unlink）的完整流程。

### 重点
- 信号量的作用：同步/互斥，不能传递大量信息
- PV 操作语义：P 等待并占用（值减一），V 释放并唤醒（值加一）
- 三种信号量
  - POSIX 有名信号量：跨进程，用名（/dev/shm 下的对象），sem_open/sem_close/sem_unlink
  - POSIX 无名信号量：进程内或共享内存中，sem_init/sem_destroy
  - System V 信号量：semget/semop/semctl
- 生产者-消费者模型：写信号量初值 1、读信号量初值 0，写→读的典型配合
- 清理与健壮性：退出时 sem_unlink 删除有名信号量；错误处理与阻塞/非阻塞

### 核心概念
- 信号量（Semaphore/“信号灯”）表示一类资源的“数量”：
  - 值 > 0：可用资源个数；P 操作成功并将值减一
  - 值 = 0：无可用资源；P 操作阻塞等待
  - V 操作：释放资源，将值加一，如有等待者则唤醒
- 二值信号量（互斥锁语义）与计数信号量（资源池语义）
- 同步 vs 通信：信号量用于同步/互斥，不携带业务数据；若需传递数据，配合共享内存/消息队列等

### PV 操作（伪代码）
```c
// P(sem): 申请资源
while (true) {
  if (sem.value > 0) { sem.value--; break; }
  sleep_on_wait_queue(sem); // 阻塞等待被唤醒
}

// V(sem): 释放资源
sem.value++;
if (has_waiter(sem)) wake_one(sem);
```

### API 总览
- POSIX 有名信号量
  - sem_t* sem_open(const char* name, int oflag, mode_t mode, unsigned int value);
  - int sem_close(sem_t* sem);
  - int sem_unlink(const char* name); // 删除命名对象（/dev/shm 下）
- POSIX 无名信号量
  - int sem_init(sem_t* sem, int pshared, unsigned int value); // pshared=0 线程共享；=1 放在共享内存中供进程共享
  - int sem_destroy(sem_t* sem);
- 通用操作（两类都适用）
  - int sem_wait(sem_t* sem);        // 阻塞 P
  - int sem_trywait(sem_t* sem);     // 非阻塞 P
  - int sem_timedwait(sem_t* sem, const struct timespec* abs_timeout);
  - int sem_post(sem_t* sem);        // V
- System V 信号量（了解）
  - int semget(key_t key, int nsems, int semflg);
  - int semop(int semid, struct sembuf* sops, size_t nsops); // P/V 组合
  - int semctl(int semid, int semnum, int cmd, ...);
- 头文件与链接
  - 头文件：<semaphore.h>、<fcntl.h>、<sys/stat.h>、<signal.h>、<sys/ipc.h>、<sys/shm.h>（若配合共享内存）
  - 链接：部分系统需 -pthread 或 -lrt（视发行版/库版本而定）

### 生产者-消费者（共享内存 + 有名信号量）设计
- 目标：进程 A 写入共享内存，进程 B 读取；“写一个→读一个→再写一个→再读一个…”
- 使用两个有名信号量（示例命名）
  - 写信号量 /mysem_w：初值 1（允许首次写）
  - 读信号量 /mysem_r：初值 0（初始不可读）
- 协作流程
  - 写进程：P(/mysem_w) → 写共享内存 → V(/mysem_r)
  - 读进程：P(/mysem_r) → 读共享内存 → V(/mysem_w)
- 清理：捕捉 SIGINT（Ctrl+C）时调用 sem_unlink("/mysem_w") 与 sem_unlink("/mysem_r")，避免残留对象影响下次运行（/dev/shm 可见）

### 示例代码片段（思路）
```c
// 写进程（producer）
sem_t* sem_w = sem_open("/mysem_w", O_CREAT, 0666, 1); // 首次写：可写
sem_t* sem_r = sem_open("/mysem_r", O_CREAT, 0666, 0); // 初始不可读
// 省略：共享内存 shmget/shmat…

for (;;) {
  sem_wait(sem_w);                   // 等待可写
  // 写入共享内存
  // e.g., fgets(shm_addr, SIZE, stdin);
  sem_post(sem_r);                   // 通知可读
}

// 建议在 SIGINT 处理器中：sem_unlink("/mysem_w"); sem_unlink("/mysem_r");
```

```c
// 读进程（consumer）
sem_t* sem_w = sem_open("/mysem_w", 0);
sem_t* sem_r = sem_open("/mysem_r", 0);
// 省略：共享内存 shmget/shmat…

for (;;) {
  sem_wait(sem_r);                   // 等待可读
  // 读取共享内存并处理
  // e.g., printf("%s", shm_addr);
  sem_post(sem_w);                   // 允许下一次写
}
```

说明
- 命名对象位于 /dev/shm 下（glibc 实现常见），重复运行前如未正常清理，需要手动删除或在程序内捕捉 SIGINT 调用 sem_unlink
- 若改用 POSIX 无名信号量：将 sem_t 放在共享内存中，使用 sem_init(&sem, 1, init_val) 初始化（pshared=1）

### 与 System V 信号量的对比（简述）
- System V 更“老派”，API 偏底层（semget/semop/semctl），可一次性对多信号量做原子操作
- POSIX 接口更直观，跨平台可读性较好；有名对象管理方便
- 选择建议：新项目优先 POSIX；需兼容老系统或特定原子批处理场景可选 System V

### 实践要点与注意事项
- 初值设计
  - 典型读写一对：写信号量=1、读信号量=0
  - 资源池：设为资源个数（N）
- 清理与重复运行
  - 有名信号量需 sem_close + sem_unlink；异常退出建议在信号处理器中清理
- 错误处理
  - 所有 sem_* 调用请检查返回值；被信号打断返回 -1 且 errno=EINTR
  - 可用 sem_trywait/sem_timedwait 做超时/非阻塞控制
- 多生产者/多消费者
  - 读写双方都可能并发；必要时增加互斥（如额外的互斥量/二值信号量）保护共享缓冲区的结构性修改
- 与数据通道组合
  - 信号量只做同步；数据请放共享内存/队列；定义好消息边界与内存可见性
- 编译链接
  - 某些平台需要 -pthread 或 -lrt；以实际工具链为准

### 小结
- 信号量通过“计数 + PV 操作”为进程/线程提供轻量级同步能力
- POSIX 有名/无名两种形态覆盖跨进程与进程内/共享内存场景，System V 为传统备选
- 生产者-消费者用两个信号量的经典方案可实现稳定、无忙等的读写协作
- 良好清理（sem_unlink）、完备的错误处理与合理的初值设计，是编写健壮同步程序的关键



## 十八、POSIX 无名信号量：线程同步与 PV 操作实战

### 摘要
本节讲解如何用 POSIX 无名信号量在同一进程内实现线程间同步。围绕信号量的 PV 机制（P=等待/占用，V=释放/唤醒），给出无名信号量的初始化与销毁 API（sem_init/sem_destroy），以及与有名信号量在使用方式上的差异。通过“读写线程协作”的示例（写线程生产输入、读线程消费输出），展示用两个信号量实现无忙等的有序读写，避免竞态条件。

### 重点
- 无名信号量用于同一进程内线程间同步（本课程场景），与有名信号量的 PV 操作相同
- 初始化与销毁不同：sem_init/sem_destroy（无名） vs sem_open/sem_close/sem_unlink（有名）
- 典型设计：写信号量初值 1、读信号量初值 0，实现“写一个→读一个”的节拍控制
- 线程模型：pthread_create 创建读线程；写线程在主线程中执行

### 核心概念回顾
- 信号量表示可用资源“计数”
  - P 操作：若计数>0 则减一并继续；否则阻塞等待
  - V 操作：计数加一，如有等待线程则唤醒
- 用途：同步/互斥，不承载业务数据；数据放在共享区（进程内可用全局/堆内存）

### API 与用法
- 头文件与链接
  - 头文件：<semaphore.h>, <pthread.h>, <stdio.h>, <string.h>, <unistd.h>
  - 编译：gcc -pthread file.c -o app
- 无名信号量
  - int sem_init(sem_t* sem, int pshared, unsigned int value);
    - pshared=0：仅线程共享（本课程场景）
    - value：初始计数
  - int sem_destroy(sem_t* sem);
  - int sem_wait(sem_t* sem);        // 阻塞 P
  - int sem_trywait(sem_t* sem);     // 非阻塞 P
  - int sem_timedwait(sem_t* sem, const struct timespec* abs_timeout);
  - int sem_post(sem_t* sem);        // V

### 线程协作示例（写→读 的节拍控制）
```c
#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define BUF_SZ 512

static sem_t sem_w; // 写信号量：允许写
static sem_t sem_r; // 读信号量：允许读
static char shared_buf[BUF_SZ];

// 读线程：等待可读 → 打印 → 允许下一次写
static void* reader_thread(void* arg) {
  (void)arg;
  for (;;) {
    sem_wait(&sem_r);                 // P(读)
    // 模拟消费
    printf("[reader] %s", shared_buf);
    fflush(stdout);
    sem_post(&sem_w);                 // V(写)
  }
  return NULL;
}

int main(void) {
  // 初始化：首次允许写、禁止读
  sem_init(&sem_w, 0, 1);             // pshared=0, value=1
  sem_init(&sem_r, 0, 0);             // pshared=0, value=0

  pthread_t tid;
  pthread_create(&tid, NULL, reader_thread, NULL);

  // 写线程逻辑：等待可写 → 从 stdin 读入 → 允许读者消费
  char line[BUF_SZ];
  while (fgets(line, sizeof line, stdin)) {
    sem_wait(&sem_w);                 // P(写)
    strncpy(shared_buf, line, BUF_SZ);
    shared_buf[BUF_SZ - 1] = '\0';
    sem_post(&sem_r);                 // V(读)
  }

  // 示例简单起见：进程结束由外部控制（如 Ctrl+C）
  // 资源清理（若能安全终止 reader）：
  // pthread_cancel(tid); pthread_join(tid, NULL);
  sem_destroy(&sem_w);
  sem_destroy(&sem_r);
  return 0;
}
```

- 运行与测试
  - 编译：gcc -pthread sem_unnamed_demo.c -o demo
  - 运行：./demo
  - 逐行输入，读线程将逐条消费并打印，体现“写一条→读一条”的同步

### 与有名信号量的区别（要点）
- 有名：跨进程可见，基于名字管理对象（常位于 /dev/shm），API 为 sem_open/sem_close/sem_unlink
- 无名：对象存在于进程地址空间（变量或共享内存区），API 为 sem_init/sem_destroy
- 本节场景聚焦线程间同步；进程间同步请使用有名信号量或将无名信号量放入共享内存并视平台支持情况使用

### 实践要点与注意事项
- 初始化值设计
  - 单槽读写：写=1、读=0；N 槽缓冲可设写=N、读=0，配合环形队列
- 线程安全
  - 若共享的是复杂结构（队列、索引等），除信号量外通常还需互斥锁保护结构性更新
- 退出与清理
  - 合理终止读线程（标志/管道化/取消点），并 join 后再 sem_destroy
- 错误处理
  - 检查 sem_* 与 pthread_* 返回值；被信号中断时 sem_* 可返回 -1 且 errno=EINTR
- 非阻塞/超时
  - 需要尽快返回时用 sem_trywait 或 sem_timedwait
- 可见性
  - 同一进程内，sem_* 已提供必要的同步序；对跨线程共享的普通内存，紧跟在 sem_wait/sem_post 后的读写满足典型可见性语义

### 小结
- 无名信号量为“同进程多线程”的同步提供了简洁高效的机制，PV 操作语义与有名信号量一致
- 通过“写=1、读=0”的两信号量设计，可轻松实现一写一读的可靠节拍控制，避免竞态与忙等
- 掌握 sem_init/sem_destroy 与 sem_wait/sem_post 的组合，是构建稳健线程同步方案的基础


## 十九、System V 信号量（信号灯）：API、PV 操作与共享内存同步实战

### 摘要
本节系统介绍 System V 信号量的概念与用法。它与消息队列、共享内存同属 System V IPC 家族，适用于进程间同步。相较 POSIX 信号量，System V 的 API 更底层，需手动维护键值、ID、联合体与操作结构，但原理相同：通过 P（-1）/V（+1）操作控制有限资源或同步节拍。课程以“共享内存 + 双信号量 + fork”的生产者-消费者示例，演示从创建、初始化、PV 操作到清理删除的完整流程。

### 重点
- IPC 家族：与消息队列（msg*）、共享内存（shm*）同系列（ftok/key/ID 模式）
- 三大 API：
  - semget：创建/打开信号量集合（可一次包含多个信号量）
  - semop：提交一组原子 P/V 操作（struct sembuf 队列）
  - semctl：控制/初始化/查询/删除（IPC_RMID）
- 典型模式：两个信号量（读=0，写=1）驱动“写→读→写→读…”的同步
- 示例：创建 key → semget → shmget/shmat → semctl 初始化 → fork → 父写/子读（或反之）→ 清理

### API 概览
- 头文件
  - #include <sys/ipc.h>
  - #include <sys/sem.h>
  - #include <sys/shm.h>
  - #include <unistd.h>, <stdio.h>, <stdlib.h>, <string.h>（按需）
- 键与 ID
  - key_t key = ftok(pathname, proj_id);
  - int semid = semget(key, nsems, ipc_flags_perm);
  - int shmid = shmget(key, size, ipc_flags_perm);

- 创建/打开
  - int semget(key_t key, int nsems, int semflg);
    - nsems：集合中信号量个数
    - semflg：权限位与 IPC_CREAT | IPC_EXCL 等

- PV 操作（原子）
  - int semop(int semid, struct sembuf sops[], size_t nsops);
    - struct sembuf { unsigned short sem_num; short sem_op; short sem_flg; }
    - sem_op:
      - -1：P（等待/占用），若值为 0 则阻塞（无 IPC_NOWAIT）
      - +1：V（释放/生产）
      - 0：等待该信号量值为 0
    - sem_flg：0 或 IPC_NOWAIT 等

- 控制/初始化/删除
  - int semctl(int semid, int semnum, int cmd, ...);
    - 常用 cmd：SETVAL/GETVAL/IPC_RMID/GETPID/GETNCNT/GETZCNT/SETALL/GETALL
    - 初始化单个信号量值：SETVAL
    - 删除整个集合：IPC_RMID（semnum 忽略）

- 注意：很多系统未在头文件中定义 union semun，需自行定义

### 常用联合体定义
```c
// 某些实现需要自行提供
union semun {
  int              val;    // SETVAL
  struct semid_ds* buf;    // IPC_STAT/IPC_SET
  unsigned short*  array;  // GETALL/SETALL
  struct seminfo*  __buf;  // IPC_INFO（可选）
};
```

### 典型初始化与 PV 封装
```c
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

union semun { int val; struct semid_ds* buf; unsigned short* array; struct seminfo* __buf; };

// 两个信号量索引
enum { SEM_READ = 0, SEM_WRITE = 1 };

// P 操作：sem_op = -1
static int P(int semid, unsigned short sem_num) {
  struct sembuf op = { .sem_num = sem_num, .sem_op = -1, .sem_flg = 0 };
  return semop(semid, &op, 1);
}

// V 操作：sem_op = +1
static int V(int semid, unsigned short sem_num) {
  struct sembuf op = { .sem_num = sem_num, .sem_op = +1, .sem_flg = 0 };
  return semop(semid, &op, 1);
}
```

### 示例流程：共享内存 + 双信号量 + fork
- 目标：父进程写共享内存，子进程读；按“写=1、读=0”初值保证节拍
- 初始化策略
  - SETVAL(SEM_WRITE) = 1（允许首次写）
  - SETVAL(SEM_READ)  = 0（初始不可读）

```c
#define SHM_SIZE 512

int main(void) {
  // 1) 生成 key
  key_t key = ftok(".", 0x42);
  if (key == -1) { perror("ftok"); return 1; }

  // 2) 创建信号量集合（2 个）
  int semid = semget(key, 2, IPC_CREAT | 0666);
  if (semid == -1) { perror("semget"); return 1; }

  // 3) 初始化两个信号量的值
  union semun arg;
  arg.val = 0;
  if (semctl(semid, SEM_READ, SETVAL, arg) == -1) { perror("semctl SETVAL read"); return 1; }
  arg.val = 1;
  if (semctl(semid, SEM_WRITE, SETVAL, arg) == -1) { perror("semctl SETVAL write"); return 1; }

  // 4) 共享内存
  int shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
  if (shmid == -1) { perror("shmget"); return 1; }
  char* shm = shmat(shmid, NULL, 0);
  if (shm == (void*)-1) { perror("shmat"); return 1; }

  // 5) fork：父写子读
  pid_t pid = fork();
  if (pid < 0) {
    perror("fork");
    shmctl(shmid, IPC_RMID, NULL);
    semctl(semid, 0, IPC_RMID); // 删除整个集合
    return 1;
  }

  if (pid == 0) {
    // 子进程：读者
    for (;;) {
      if (P(semid, SEM_READ) == -1) { perror("P read"); break; }
      printf("[child] %s", shm);
      fflush(stdout);
      if (V(semid, SEM_WRITE) == -1) { perror("V write"); break; }
    }
    _exit(0);
  } else {
    // 父进程：写者
    char line[SHM_SIZE];
    while (fgets(line, sizeof line, stdin)) {
      if (P(semid, SEM_WRITE) == -1) { perror("P write"); break; }
      strncpy(shm, line, SHM_SIZE);
      shm[SHM_SIZE - 1] = '\0';
      if (V(semid, SEM_READ) == -1) { perror("V read"); break; }
    }
    // 简化：输入结束后清理资源
    shmdt(shm);
    shmctl(shmid, IPC_RMID, NULL);
    semctl(semid, 0, IPC_RMID); // 删除集合
  }
  return 0;
}
```

说明
- 两个信号量在同一集合内，通过 sem_num 区分
- P/V 函数只对单个信号量进行操作；也可用 semop 传入多条 sembuf 实现跨信号量的原子批处理
- 初始化时用 semctl(SETVAL) 设置计数；删除集合用 semctl(IPC_RMID)
- 若需非阻塞，设置 sem_flg = IPC_NOWAIT 并检查返回值/errno

### 实践要点与注意事项
- 原子性：semop 能一次提交多条操作，保证跨信号量的原子同步；是 System V 的优势之一
- 初始化
  - 二值/互斥场景：设 0/1
  - 计数场景：设资源总数 N
- 错误处理
  - 被信号中断返回 -1 且 errno=EINTR，可按需重试
  - 非阻塞 P 遇到不可用返回 -1 且 errno=EAGAIN
- 清理
  - 进程异常退出可能残留对象；使用 IPC_RMID 删除；共享内存也需 shmctl(IPC_RMID)
- 设计建议
  - 读写双信号量模式简单直观；复杂缓冲（多槽/环形队列）可扩展为更多信号量或配合共享结构
  - 若仅需线程内同步，优先使用 POSIX 无名信号量；跨进程推荐 POSIX 有名或 System V，视平台与维护偏好选择

### 小结
- System V 信号量与消息队列、共享内存同属 IPC 家族，基于 key/id 操作
- 核心在于 semget（建/取）、semctl（设/查/删）、semop（原子 PV）
- 以“双信号量 + 共享内存 + fork”可轻松构建可靠的进程间同步通信
- 掌握 SETVAL/IPC_RMID、sembuf 语义与多操作原子性，是熟练使用 System V 信号量的关键